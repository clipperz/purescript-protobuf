-- | plugin.Google.Protobuf.Compiler.purs generated by purescript-protobuf from file src/ProtocPlugin/plugin.proto
module Google.Protobuf.Compiler.Plugin
( Version(..), VersionR, parseVersion, putVersion
, CodeGeneratorRequest(..), CodeGeneratorRequestR, parseCodeGeneratorRequest, putCodeGeneratorRequest
, CodeGeneratorResponse(..), CodeGeneratorResponseR, parseCodeGeneratorResponse, putCodeGeneratorResponse
, CodeGeneratorResponse_File(..), CodeGeneratorResponse_FileR, parseCodeGeneratorResponse_File, putCodeGeneratorResponse_File
, CodeGeneratorResponse_Feature(..)
)
where

import Prelude
import Effect.Class as Effect
import Record.Builder as Record.Builder
import Data.Array as Array
import Data.Bounded as Bounded
import Data.Enum as Enum
import Data.Eq as Eq
import Data.Function as Function
import Data.Float32 as Float32
import Data.Show as Show
import Data.Ord as Ord
import Data.Maybe as Maybe
import Data.Newtype as Newtype
import Data.Generic.Rep as Generic.Rep
import Data.Generic.Rep.Show as Generic.Rep.Show
import Data.Generic.Rep.Bounded as Generic.Rep.Bounded
import Data.Generic.Rep.Enum as Generic.Rep.Enum
import Data.Generic.Rep.Ord as Generic.Rep.Ord
import Data.Semigroup as Semigroup
import Data.Symbol as Symbol
import Data.UInt as UInt
import Data.Unit as Unit
import Data.Long.Internal as Long
import Text.Parsing.Parser as Parser
import Data.ArrayBuffer.Builder as ArrayBuffer.Builder
import Data.ArrayBuffer.Types as ArrayBuffer.Types
import Protobuf.Common as Common
import Protobuf.Decode as Decode
import Protobuf.Encode as Encode
import Protobuf.Runtime as Runtime

import Google.Protobuf.Descriptor as Google.Protobuf



type VersionR =
  { major :: Maybe.Maybe Int
  , minor :: Maybe.Maybe Int
  , patch :: Maybe.Maybe Int
  , suffix :: Maybe.Maybe String
  }
newtype Version = Version VersionR
derive instance genericVersion :: Generic.Rep.Generic Version _
derive instance newtypeVersion :: Newtype.Newtype Version _

putVersion :: forall m. Effect.MonadEffect m => Version -> ArrayBuffer.Builder.PutM m Unit.Unit
putVersion (Version r) = do
  Runtime.putOptional 1 r.major Encode.int32
  Runtime.putOptional 2 r.minor Encode.int32
  Runtime.putOptional 3 r.patch Encode.int32
  Runtime.putOptional 4 r.suffix Encode.string

parseVersion :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m Version
parseVersion length =
  Runtime.parseMessage Version default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder VersionR VersionR)
  parseField 1 Common.VarInt = do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "major") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "minor") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "patch") $ Function.const $ Maybe.Just x
  parseField 4 Common.LenDel = do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "suffix") $ Function.const $ Maybe.Just x
  parseField _ wireType = Runtime.parseFieldUnknown wireType
  default =
    { major: Maybe.Nothing
    , minor: Maybe.Nothing
    , patch: Maybe.Nothing
    , suffix: Maybe.Nothing
    }


type CodeGeneratorRequestR =
  { file_to_generate :: Array String
  , parameter :: Maybe.Maybe String
  , proto_file :: Array Google.Protobuf.FileDescriptorProto
  , compiler_version :: Maybe.Maybe Version
  }
newtype CodeGeneratorRequest = CodeGeneratorRequest CodeGeneratorRequestR
derive instance genericCodeGeneratorRequest :: Generic.Rep.Generic CodeGeneratorRequest _
derive instance newtypeCodeGeneratorRequest :: Newtype.Newtype CodeGeneratorRequest _

putCodeGeneratorRequest :: forall m. Effect.MonadEffect m => CodeGeneratorRequest -> ArrayBuffer.Builder.PutM m Unit.Unit
putCodeGeneratorRequest (CodeGeneratorRequest r) = do
  Runtime.putRepeated 1 r.file_to_generate Encode.string
  Runtime.putOptional 2 r.parameter Encode.string
  Runtime.putRepeated 15 r.proto_file $ Runtime.putLenDel Google.Protobuf.putFileDescriptorProto
  Runtime.putOptional 3 r.compiler_version $ Runtime.putLenDel putVersion

parseCodeGeneratorRequest :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m CodeGeneratorRequest
parseCodeGeneratorRequest length =
  Runtime.parseMessage CodeGeneratorRequest default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder CodeGeneratorRequestR CodeGeneratorRequestR)
  parseField 1 Common.LenDel = do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "file_to_generate") $ Function.flip Array.snoc x
  parseField 2 Common.LenDel = do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "parameter") $ Function.const $ Maybe.Just x
  parseField 15 Common.LenDel = do
    x <- Runtime.parseLenDel Google.Protobuf.parseFileDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "proto_file") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = do
    x <- Runtime.parseLenDel parseVersion
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "compiler_version") $ Function.const $ Maybe.Just x
  parseField _ wireType = Runtime.parseFieldUnknown wireType
  default =
    { file_to_generate: []
    , parameter: Maybe.Nothing
    , proto_file: []
    , compiler_version: Maybe.Nothing
    }


type CodeGeneratorResponseR =
  { error :: Maybe.Maybe String
  , supported_features :: Maybe.Maybe (Long.Long Long.Unsigned)
  , file :: Array CodeGeneratorResponse_File
  }
newtype CodeGeneratorResponse = CodeGeneratorResponse CodeGeneratorResponseR
derive instance genericCodeGeneratorResponse :: Generic.Rep.Generic CodeGeneratorResponse _
derive instance newtypeCodeGeneratorResponse :: Newtype.Newtype CodeGeneratorResponse _

putCodeGeneratorResponse :: forall m. Effect.MonadEffect m => CodeGeneratorResponse -> ArrayBuffer.Builder.PutM m Unit.Unit
putCodeGeneratorResponse (CodeGeneratorResponse r) = do
  Runtime.putOptional 1 r.error Encode.string
  Runtime.putOptional 2 r.supported_features Encode.uint64
  Runtime.putRepeated 15 r.file $ Runtime.putLenDel putCodeGeneratorResponse_File

parseCodeGeneratorResponse :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m CodeGeneratorResponse
parseCodeGeneratorResponse length =
  Runtime.parseMessage CodeGeneratorResponse default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder CodeGeneratorResponseR CodeGeneratorResponseR)
  parseField 1 Common.LenDel = do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "error") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = do
    x <- Decode.uint64
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "supported_features") $ Function.const $ Maybe.Just x
  parseField 15 Common.LenDel = do
    x <- Runtime.parseLenDel parseCodeGeneratorResponse_File
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "file") $ Function.flip Array.snoc x
  parseField _ wireType = Runtime.parseFieldUnknown wireType
  default =
    { error: Maybe.Nothing
    , supported_features: Maybe.Nothing
    , file: []
    }


type CodeGeneratorResponse_FileR =
  { name :: Maybe.Maybe String
  , insertion_point :: Maybe.Maybe String
  , content :: Maybe.Maybe String
  }
newtype CodeGeneratorResponse_File = CodeGeneratorResponse_File CodeGeneratorResponse_FileR
derive instance genericCodeGeneratorResponse_File :: Generic.Rep.Generic CodeGeneratorResponse_File _
derive instance newtypeCodeGeneratorResponse_File :: Newtype.Newtype CodeGeneratorResponse_File _

putCodeGeneratorResponse_File :: forall m. Effect.MonadEffect m => CodeGeneratorResponse_File -> ArrayBuffer.Builder.PutM m Unit.Unit
putCodeGeneratorResponse_File (CodeGeneratorResponse_File r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.insertion_point Encode.string
  Runtime.putOptional 15 r.content Encode.string

parseCodeGeneratorResponse_File :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m CodeGeneratorResponse_File
parseCodeGeneratorResponse_File length =
  Runtime.parseMessage CodeGeneratorResponse_File default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder CodeGeneratorResponse_FileR CodeGeneratorResponse_FileR)
  parseField 1 Common.LenDel = do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "insertion_point") $ Function.const $ Maybe.Just x
  parseField 15 Common.LenDel = do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "content") $ Function.const $ Maybe.Just x
  parseField _ wireType = Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , insertion_point: Maybe.Nothing
    , content: Maybe.Nothing
    }


data CodeGeneratorResponse_Feature
  = CodeGeneratorResponse_Feature_FEATURE_NONE
  | CodeGeneratorResponse_Feature_FEATURE_PROTO3_OPTIONAL
derive instance genericCodeGeneratorResponse_Feature :: Generic.Rep.Generic CodeGeneratorResponse_Feature _
derive instance eqCodeGeneratorResponse_Feature :: Eq.Eq CodeGeneratorResponse_Feature
instance showCodeGeneratorResponse_Feature :: Show.Show CodeGeneratorResponse_Feature where show = Generic.Rep.Show.genericShow
instance ordCodeGeneratorResponse_Feature :: Ord.Ord CodeGeneratorResponse_Feature where compare = Generic.Rep.Ord.genericCompare
instance boundedCodeGeneratorResponse_Feature :: Bounded.Bounded CodeGeneratorResponse_Feature
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumCodeGeneratorResponse_Feature :: Enum.Enum CodeGeneratorResponse_Feature
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumCodeGeneratorResponse_Feature :: Enum.BoundedEnum CodeGeneratorResponse_Feature
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 0 = Maybe.Just CodeGeneratorResponse_Feature_FEATURE_NONE
  toEnum 1 = Maybe.Just CodeGeneratorResponse_Feature_FEATURE_PROTO3_OPTIONAL
  toEnum _ = Maybe.Nothing
  fromEnum CodeGeneratorResponse_Feature_FEATURE_NONE = 0
  fromEnum CodeGeneratorResponse_Feature_FEATURE_PROTO3_OPTIONAL = 1

