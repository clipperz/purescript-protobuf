-- | Generated by __purescript-protobuf__ from file `google/protobuf/descriptor.proto`
module Google.Protobuf.Descriptor
( FileDescriptorSet(..), FileDescriptorSetR, parseFileDescriptorSet, putFileDescriptorSet
, FileDescriptorProto(..), FileDescriptorProtoR, parseFileDescriptorProto, putFileDescriptorProto
, DescriptorProto(..), DescriptorProtoR, parseDescriptorProto, putDescriptorProto
, DescriptorProto_ExtensionRange(..), DescriptorProto_ExtensionRangeR, parseDescriptorProto_ExtensionRange, putDescriptorProto_ExtensionRange
, DescriptorProto_ReservedRange(..), DescriptorProto_ReservedRangeR, parseDescriptorProto_ReservedRange, putDescriptorProto_ReservedRange
, ExtensionRangeOptions(..), ExtensionRangeOptionsR, parseExtensionRangeOptions, putExtensionRangeOptions
, FieldDescriptorProto(..), FieldDescriptorProtoR, parseFieldDescriptorProto, putFieldDescriptorProto
, OneofDescriptorProto(..), OneofDescriptorProtoR, parseOneofDescriptorProto, putOneofDescriptorProto
, EnumDescriptorProto(..), EnumDescriptorProtoR, parseEnumDescriptorProto, putEnumDescriptorProto
, EnumDescriptorProto_EnumReservedRange(..), EnumDescriptorProto_EnumReservedRangeR, parseEnumDescriptorProto_EnumReservedRange, putEnumDescriptorProto_EnumReservedRange
, EnumValueDescriptorProto(..), EnumValueDescriptorProtoR, parseEnumValueDescriptorProto, putEnumValueDescriptorProto
, ServiceDescriptorProto(..), ServiceDescriptorProtoR, parseServiceDescriptorProto, putServiceDescriptorProto
, MethodDescriptorProto(..), MethodDescriptorProtoR, parseMethodDescriptorProto, putMethodDescriptorProto
, FileOptions(..), FileOptionsR, parseFileOptions, putFileOptions
, MessageOptions(..), MessageOptionsR, parseMessageOptions, putMessageOptions
, FieldOptions(..), FieldOptionsR, parseFieldOptions, putFieldOptions
, OneofOptions(..), OneofOptionsR, parseOneofOptions, putOneofOptions
, EnumOptions(..), EnumOptionsR, parseEnumOptions, putEnumOptions
, EnumValueOptions(..), EnumValueOptionsR, parseEnumValueOptions, putEnumValueOptions
, ServiceOptions(..), ServiceOptionsR, parseServiceOptions, putServiceOptions
, MethodOptions(..), MethodOptionsR, parseMethodOptions, putMethodOptions
, UninterpretedOption(..), UninterpretedOptionR, parseUninterpretedOption, putUninterpretedOption
, UninterpretedOption_NamePart(..), UninterpretedOption_NamePartR, parseUninterpretedOption_NamePart, putUninterpretedOption_NamePart
, SourceCodeInfo(..), SourceCodeInfoR, parseSourceCodeInfo, putSourceCodeInfo
, SourceCodeInfo_Location(..), SourceCodeInfo_LocationR, parseSourceCodeInfo_Location, putSourceCodeInfo_Location
, GeneratedCodeInfo(..), GeneratedCodeInfoR, parseGeneratedCodeInfo, putGeneratedCodeInfo
, GeneratedCodeInfo_Annotation(..), GeneratedCodeInfo_AnnotationR, parseGeneratedCodeInfo_Annotation, putGeneratedCodeInfo_Annotation
, FieldDescriptorProto_Type(..)
, FieldDescriptorProto_Label(..)
, FileOptions_OptimizeMode(..)
, FieldOptions_CType(..)
, FieldOptions_JSType(..)
, MethodOptions_IdempotencyLevel(..)
)
where

import Prelude
import Effect.Class as Effect
import Record.Builder as Record.Builder
import Data.Array as Array
import Data.Bounded as Bounded
import Data.Enum as Enum
import Data.Eq as Eq
import Data.Function as Function
import Data.Float32 as Float32
import Data.Show as Show
import Data.Ord as Ord
import Data.Maybe as Maybe
import Data.Newtype as Newtype
import Data.Generic.Rep as Generic.Rep
import Data.Generic.Rep.Show as Generic.Rep.Show
import Data.Generic.Rep.Bounded as Generic.Rep.Bounded
import Data.Generic.Rep.Enum as Generic.Rep.Enum
import Data.Generic.Rep.Ord as Generic.Rep.Ord
import Data.Semigroup as Semigroup
import Data.Symbol as Symbol
import Data.UInt as UInt
import Data.Unit as Unit
import Data.Long.Internal as Long
import Text.Parsing.Parser as Parser
import Data.ArrayBuffer.Builder as ArrayBuffer.Builder
import Data.ArrayBuffer.Types as ArrayBuffer.Types
import Protobuf.Common as Common
import Protobuf.Decode as Decode
import Protobuf.Encode as Encode
import Protobuf.Runtime as Runtime




type FileDescriptorSetR =
  { file :: Array FileDescriptorProto
  }
newtype FileDescriptorSet = FileDescriptorSet FileDescriptorSetR
derive instance genericFileDescriptorSet :: Generic.Rep.Generic FileDescriptorSet _
derive instance newtypeFileDescriptorSet :: Newtype.Newtype FileDescriptorSet _

putFileDescriptorSet :: forall m. Effect.MonadEffect m => FileDescriptorSet -> ArrayBuffer.Builder.PutM m Unit.Unit
putFileDescriptorSet (FileDescriptorSet r) = do
  Runtime.putRepeated 1 r.file $ Runtime.putLenDel putFileDescriptorProto

parseFileDescriptorSet :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FileDescriptorSet
parseFileDescriptorSet length = Runtime.label "FileDescriptorSet / " $
  Runtime.parseMessage FileDescriptorSet default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FileDescriptorSetR FileDescriptorSetR)
  parseField 1 Common.LenDel = Runtime.label "file / " $ do
    x <- Runtime.parseLenDel parseFileDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "file") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { file: []
    }


type FileDescriptorProtoR =
  { name :: Maybe.Maybe String
  , package :: Maybe.Maybe String
  , dependency :: Array String
  , public_dependency :: Array Int
  , weak_dependency :: Array Int
  , message_type :: Array DescriptorProto
  , enum_type :: Array EnumDescriptorProto
  , service :: Array ServiceDescriptorProto
  , extension :: Array FieldDescriptorProto
  , options :: Maybe.Maybe FileOptions
  , source_code_info :: Maybe.Maybe SourceCodeInfo
  , syntax :: Maybe.Maybe String
  }
newtype FileDescriptorProto = FileDescriptorProto FileDescriptorProtoR
derive instance genericFileDescriptorProto :: Generic.Rep.Generic FileDescriptorProto _
derive instance newtypeFileDescriptorProto :: Newtype.Newtype FileDescriptorProto _

putFileDescriptorProto :: forall m. Effect.MonadEffect m => FileDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putFileDescriptorProto (FileDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.package Encode.string
  Runtime.putRepeated 3 r.dependency Encode.string
  Runtime.putPacked 10 r.public_dependency Encode.int32'
  Runtime.putPacked 11 r.weak_dependency Encode.int32'
  Runtime.putRepeated 4 r.message_type $ Runtime.putLenDel putDescriptorProto
  Runtime.putRepeated 5 r.enum_type $ Runtime.putLenDel putEnumDescriptorProto
  Runtime.putRepeated 6 r.service $ Runtime.putLenDel putServiceDescriptorProto
  Runtime.putRepeated 7 r.extension $ Runtime.putLenDel putFieldDescriptorProto
  Runtime.putOptional 8 r.options $ Runtime.putLenDel putFileOptions
  Runtime.putOptional 9 r.source_code_info $ Runtime.putLenDel putSourceCodeInfo
  Runtime.putOptional 12 r.syntax Encode.string

parseFileDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FileDescriptorProto
parseFileDescriptorProto length = Runtime.label "FileDescriptorProto / " $
  Runtime.parseMessage FileDescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FileDescriptorProtoR FileDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "package") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "dependency / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "dependency") $ Function.flip Array.snoc x
  parseField 10 Common.VarInt = Runtime.label "public_dependency / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "public_dependency") $ Function.flip Array.snoc x
  parseField 10 Common.LenDel = Runtime.label "public_dependency / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "public_dependency") $ Function.flip Semigroup.append x
  parseField 11 Common.VarInt = Runtime.label "weak_dependency / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "weak_dependency") $ Function.flip Array.snoc x
  parseField 11 Common.LenDel = Runtime.label "weak_dependency / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "weak_dependency") $ Function.flip Semigroup.append x
  parseField 4 Common.LenDel = Runtime.label "message_type / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "message_type") $ Function.flip Array.snoc x
  parseField 5 Common.LenDel = Runtime.label "enum_type / " $ do
    x <- Runtime.parseLenDel parseEnumDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "enum_type") $ Function.flip Array.snoc x
  parseField 6 Common.LenDel = Runtime.label "service / " $ do
    x <- Runtime.parseLenDel parseServiceDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "service") $ Function.flip Array.snoc x
  parseField 7 Common.LenDel = Runtime.label "extension / " $ do
    x <- Runtime.parseLenDel parseFieldDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extension") $ Function.flip Array.snoc x
  parseField 8 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseFileOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 9 Common.LenDel = Runtime.label "source_code_info / " $ do
    x <- Runtime.parseLenDel parseSourceCodeInfo
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "source_code_info") $ Function.const $ Maybe.Just x
  parseField 12 Common.LenDel = Runtime.label "syntax / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "syntax") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , package: Maybe.Nothing
    , dependency: []
    , public_dependency: []
    , weak_dependency: []
    , message_type: []
    , enum_type: []
    , service: []
    , extension: []
    , options: Maybe.Nothing
    , source_code_info: Maybe.Nothing
    , syntax: Maybe.Nothing
    }


type DescriptorProtoR =
  { name :: Maybe.Maybe String
  , field :: Array FieldDescriptorProto
  , extension :: Array FieldDescriptorProto
  , nested_type :: Array DescriptorProto
  , enum_type :: Array EnumDescriptorProto
  , extension_range :: Array DescriptorProto_ExtensionRange
  , oneof_decl :: Array OneofDescriptorProto
  , options :: Maybe.Maybe MessageOptions
  , reserved_range :: Array DescriptorProto_ReservedRange
  , reserved_name :: Array String
  }
newtype DescriptorProto = DescriptorProto DescriptorProtoR
derive instance genericDescriptorProto :: Generic.Rep.Generic DescriptorProto _
derive instance newtypeDescriptorProto :: Newtype.Newtype DescriptorProto _

putDescriptorProto :: forall m. Effect.MonadEffect m => DescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putDescriptorProto (DescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putRepeated 2 r.field $ Runtime.putLenDel putFieldDescriptorProto
  Runtime.putRepeated 6 r.extension $ Runtime.putLenDel putFieldDescriptorProto
  Runtime.putRepeated 3 r.nested_type $ Runtime.putLenDel putDescriptorProto
  Runtime.putRepeated 4 r.enum_type $ Runtime.putLenDel putEnumDescriptorProto
  Runtime.putRepeated 5 r.extension_range $ Runtime.putLenDel putDescriptorProto_ExtensionRange
  Runtime.putRepeated 8 r.oneof_decl $ Runtime.putLenDel putOneofDescriptorProto
  Runtime.putOptional 7 r.options $ Runtime.putLenDel putMessageOptions
  Runtime.putRepeated 9 r.reserved_range $ Runtime.putLenDel putDescriptorProto_ReservedRange
  Runtime.putRepeated 10 r.reserved_name Encode.string

parseDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m DescriptorProto
parseDescriptorProto length = Runtime.label "DescriptorProto / " $
  Runtime.parseMessage DescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder DescriptorProtoR DescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "field / " $ do
    x <- Runtime.parseLenDel parseFieldDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "field") $ Function.flip Array.snoc x
  parseField 6 Common.LenDel = Runtime.label "extension / " $ do
    x <- Runtime.parseLenDel parseFieldDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extension") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "nested_type / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "nested_type") $ Function.flip Array.snoc x
  parseField 4 Common.LenDel = Runtime.label "enum_type / " $ do
    x <- Runtime.parseLenDel parseEnumDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "enum_type") $ Function.flip Array.snoc x
  parseField 5 Common.LenDel = Runtime.label "extension_range / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto_ExtensionRange
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extension_range") $ Function.flip Array.snoc x
  parseField 8 Common.LenDel = Runtime.label "oneof_decl / " $ do
    x <- Runtime.parseLenDel parseOneofDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "oneof_decl") $ Function.flip Array.snoc x
  parseField 7 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseMessageOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 9 Common.LenDel = Runtime.label "reserved_range / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto_ReservedRange
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_range") $ Function.flip Array.snoc x
  parseField 10 Common.LenDel = Runtime.label "reserved_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_name") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , field: []
    , extension: []
    , nested_type: []
    , enum_type: []
    , extension_range: []
    , oneof_decl: []
    , options: Maybe.Nothing
    , reserved_range: []
    , reserved_name: []
    }


type DescriptorProto_ExtensionRangeR =
  { start :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  , options :: Maybe.Maybe ExtensionRangeOptions
  }
newtype DescriptorProto_ExtensionRange = DescriptorProto_ExtensionRange DescriptorProto_ExtensionRangeR
derive instance genericDescriptorProto_ExtensionRange :: Generic.Rep.Generic DescriptorProto_ExtensionRange _
derive instance newtypeDescriptorProto_ExtensionRange :: Newtype.Newtype DescriptorProto_ExtensionRange _

putDescriptorProto_ExtensionRange :: forall m. Effect.MonadEffect m => DescriptorProto_ExtensionRange -> ArrayBuffer.Builder.PutM m Unit.Unit
putDescriptorProto_ExtensionRange (DescriptorProto_ExtensionRange r) = do
  Runtime.putOptional 1 r.start Encode.int32
  Runtime.putOptional 2 r.end Encode.int32
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putExtensionRangeOptions

parseDescriptorProto_ExtensionRange :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m DescriptorProto_ExtensionRange
parseDescriptorProto_ExtensionRange length = Runtime.label "ExtensionRange / " $
  Runtime.parseMessage DescriptorProto_ExtensionRange default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder DescriptorProto_ExtensionRangeR DescriptorProto_ExtensionRangeR)
  parseField 1 Common.VarInt = Runtime.label "start / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "start") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseExtensionRangeOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { start: Maybe.Nothing
    , end: Maybe.Nothing
    , options: Maybe.Nothing
    }


type DescriptorProto_ReservedRangeR =
  { start :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  }
newtype DescriptorProto_ReservedRange = DescriptorProto_ReservedRange DescriptorProto_ReservedRangeR
derive instance genericDescriptorProto_ReservedRange :: Generic.Rep.Generic DescriptorProto_ReservedRange _
derive instance newtypeDescriptorProto_ReservedRange :: Newtype.Newtype DescriptorProto_ReservedRange _

putDescriptorProto_ReservedRange :: forall m. Effect.MonadEffect m => DescriptorProto_ReservedRange -> ArrayBuffer.Builder.PutM m Unit.Unit
putDescriptorProto_ReservedRange (DescriptorProto_ReservedRange r) = do
  Runtime.putOptional 1 r.start Encode.int32
  Runtime.putOptional 2 r.end Encode.int32

parseDescriptorProto_ReservedRange :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m DescriptorProto_ReservedRange
parseDescriptorProto_ReservedRange length = Runtime.label "ReservedRange / " $
  Runtime.parseMessage DescriptorProto_ReservedRange default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder DescriptorProto_ReservedRangeR DescriptorProto_ReservedRangeR)
  parseField 1 Common.VarInt = Runtime.label "start / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "start") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { start: Maybe.Nothing
    , end: Maybe.Nothing
    }


type ExtensionRangeOptionsR =
  { uninterpreted_option :: Array UninterpretedOption
  }
newtype ExtensionRangeOptions = ExtensionRangeOptions ExtensionRangeOptionsR
derive instance genericExtensionRangeOptions :: Generic.Rep.Generic ExtensionRangeOptions _
derive instance newtypeExtensionRangeOptions :: Newtype.Newtype ExtensionRangeOptions _

putExtensionRangeOptions :: forall m. Effect.MonadEffect m => ExtensionRangeOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putExtensionRangeOptions (ExtensionRangeOptions r) = do
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseExtensionRangeOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m ExtensionRangeOptions
parseExtensionRangeOptions length = Runtime.label "ExtensionRangeOptions / " $
  Runtime.parseMessage ExtensionRangeOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder ExtensionRangeOptionsR ExtensionRangeOptionsR)
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { uninterpreted_option: []
    }


type FieldDescriptorProtoR =
  { name :: Maybe.Maybe String
  , number :: Maybe.Maybe Int
  , label :: Maybe.Maybe FieldDescriptorProto_Label
  , type :: Maybe.Maybe FieldDescriptorProto_Type
  , type_name :: Maybe.Maybe String
  , extendee :: Maybe.Maybe String
  , default_value :: Maybe.Maybe String
  , oneof_index :: Maybe.Maybe Int
  , json_name :: Maybe.Maybe String
  , options :: Maybe.Maybe FieldOptions
  }
newtype FieldDescriptorProto = FieldDescriptorProto FieldDescriptorProtoR
derive instance genericFieldDescriptorProto :: Generic.Rep.Generic FieldDescriptorProto _
derive instance newtypeFieldDescriptorProto :: Newtype.Newtype FieldDescriptorProto _

putFieldDescriptorProto :: forall m. Effect.MonadEffect m => FieldDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putFieldDescriptorProto (FieldDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 3 r.number Encode.int32
  Runtime.putOptional 4 r.label Runtime.putEnum
  Runtime.putOptional 5 r.type Runtime.putEnum
  Runtime.putOptional 6 r.type_name Encode.string
  Runtime.putOptional 2 r.extendee Encode.string
  Runtime.putOptional 7 r.default_value Encode.string
  Runtime.putOptional 9 r.oneof_index Encode.int32
  Runtime.putOptional 10 r.json_name Encode.string
  Runtime.putOptional 8 r.options $ Runtime.putLenDel putFieldOptions

parseFieldDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FieldDescriptorProto
parseFieldDescriptorProto length = Runtime.label "FieldDescriptorProto / " $
  Runtime.parseMessage FieldDescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FieldDescriptorProtoR FieldDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "number / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "number") $ Function.const $ Maybe.Just x
  parseField 4 Common.VarInt = Runtime.label "label / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "label") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "type / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "type") $ Function.const $ Maybe.Just x
  parseField 6 Common.LenDel = Runtime.label "type_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "type_name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "extendee / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extendee") $ Function.const $ Maybe.Just x
  parseField 7 Common.LenDel = Runtime.label "default_value / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "default_value") $ Function.const $ Maybe.Just x
  parseField 9 Common.VarInt = Runtime.label "oneof_index / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "oneof_index") $ Function.const $ Maybe.Just x
  parseField 10 Common.LenDel = Runtime.label "json_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "json_name") $ Function.const $ Maybe.Just x
  parseField 8 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseFieldOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , number: Maybe.Nothing
    , label: Maybe.Nothing
    , type: Maybe.Nothing
    , type_name: Maybe.Nothing
    , extendee: Maybe.Nothing
    , default_value: Maybe.Nothing
    , oneof_index: Maybe.Nothing
    , json_name: Maybe.Nothing
    , options: Maybe.Nothing
    }


type OneofDescriptorProtoR =
  { name :: Maybe.Maybe String
  , options :: Maybe.Maybe OneofOptions
  }
newtype OneofDescriptorProto = OneofDescriptorProto OneofDescriptorProtoR
derive instance genericOneofDescriptorProto :: Generic.Rep.Generic OneofDescriptorProto _
derive instance newtypeOneofDescriptorProto :: Newtype.Newtype OneofDescriptorProto _

putOneofDescriptorProto :: forall m. Effect.MonadEffect m => OneofDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putOneofDescriptorProto (OneofDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.options $ Runtime.putLenDel putOneofOptions

parseOneofDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m OneofDescriptorProto
parseOneofDescriptorProto length = Runtime.label "OneofDescriptorProto / " $
  Runtime.parseMessage OneofDescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder OneofDescriptorProtoR OneofDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseOneofOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , options: Maybe.Nothing
    }


type EnumDescriptorProtoR =
  { name :: Maybe.Maybe String
  , value :: Array EnumValueDescriptorProto
  , options :: Maybe.Maybe EnumOptions
  , reserved_range :: Array EnumDescriptorProto_EnumReservedRange
  , reserved_name :: Array String
  }
newtype EnumDescriptorProto = EnumDescriptorProto EnumDescriptorProtoR
derive instance genericEnumDescriptorProto :: Generic.Rep.Generic EnumDescriptorProto _
derive instance newtypeEnumDescriptorProto :: Newtype.Newtype EnumDescriptorProto _

putEnumDescriptorProto :: forall m. Effect.MonadEffect m => EnumDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumDescriptorProto (EnumDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putRepeated 2 r.value $ Runtime.putLenDel putEnumValueDescriptorProto
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putEnumOptions
  Runtime.putRepeated 4 r.reserved_range $ Runtime.putLenDel putEnumDescriptorProto_EnumReservedRange
  Runtime.putRepeated 5 r.reserved_name Encode.string

parseEnumDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumDescriptorProto
parseEnumDescriptorProto length = Runtime.label "EnumDescriptorProto / " $
  Runtime.parseMessage EnumDescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumDescriptorProtoR EnumDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "value / " $ do
    x <- Runtime.parseLenDel parseEnumValueDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "value") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseEnumOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 4 Common.LenDel = Runtime.label "reserved_range / " $ do
    x <- Runtime.parseLenDel parseEnumDescriptorProto_EnumReservedRange
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_range") $ Function.flip Array.snoc x
  parseField 5 Common.LenDel = Runtime.label "reserved_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_name") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , value: []
    , options: Maybe.Nothing
    , reserved_range: []
    , reserved_name: []
    }


type EnumDescriptorProto_EnumReservedRangeR =
  { start :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  }
newtype EnumDescriptorProto_EnumReservedRange = EnumDescriptorProto_EnumReservedRange EnumDescriptorProto_EnumReservedRangeR
derive instance genericEnumDescriptorProto_EnumReservedRange :: Generic.Rep.Generic EnumDescriptorProto_EnumReservedRange _
derive instance newtypeEnumDescriptorProto_EnumReservedRange :: Newtype.Newtype EnumDescriptorProto_EnumReservedRange _

putEnumDescriptorProto_EnumReservedRange :: forall m. Effect.MonadEffect m => EnumDescriptorProto_EnumReservedRange -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumDescriptorProto_EnumReservedRange (EnumDescriptorProto_EnumReservedRange r) = do
  Runtime.putOptional 1 r.start Encode.int32
  Runtime.putOptional 2 r.end Encode.int32

parseEnumDescriptorProto_EnumReservedRange :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumDescriptorProto_EnumReservedRange
parseEnumDescriptorProto_EnumReservedRange length = Runtime.label "EnumReservedRange / " $
  Runtime.parseMessage EnumDescriptorProto_EnumReservedRange default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumDescriptorProto_EnumReservedRangeR EnumDescriptorProto_EnumReservedRangeR)
  parseField 1 Common.VarInt = Runtime.label "start / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "start") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { start: Maybe.Nothing
    , end: Maybe.Nothing
    }


type EnumValueDescriptorProtoR =
  { name :: Maybe.Maybe String
  , number :: Maybe.Maybe Int
  , options :: Maybe.Maybe EnumValueOptions
  }
newtype EnumValueDescriptorProto = EnumValueDescriptorProto EnumValueDescriptorProtoR
derive instance genericEnumValueDescriptorProto :: Generic.Rep.Generic EnumValueDescriptorProto _
derive instance newtypeEnumValueDescriptorProto :: Newtype.Newtype EnumValueDescriptorProto _

putEnumValueDescriptorProto :: forall m. Effect.MonadEffect m => EnumValueDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumValueDescriptorProto (EnumValueDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.number Encode.int32
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putEnumValueOptions

parseEnumValueDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumValueDescriptorProto
parseEnumValueDescriptorProto length = Runtime.label "EnumValueDescriptorProto / " $
  Runtime.parseMessage EnumValueDescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumValueDescriptorProtoR EnumValueDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "number / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "number") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseEnumValueOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , number: Maybe.Nothing
    , options: Maybe.Nothing
    }


type ServiceDescriptorProtoR =
  { name :: Maybe.Maybe String
  , method :: Array MethodDescriptorProto
  , options :: Maybe.Maybe ServiceOptions
  }
newtype ServiceDescriptorProto = ServiceDescriptorProto ServiceDescriptorProtoR
derive instance genericServiceDescriptorProto :: Generic.Rep.Generic ServiceDescriptorProto _
derive instance newtypeServiceDescriptorProto :: Newtype.Newtype ServiceDescriptorProto _

putServiceDescriptorProto :: forall m. Effect.MonadEffect m => ServiceDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putServiceDescriptorProto (ServiceDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putRepeated 2 r.method $ Runtime.putLenDel putMethodDescriptorProto
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putServiceOptions

parseServiceDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m ServiceDescriptorProto
parseServiceDescriptorProto length = Runtime.label "ServiceDescriptorProto / " $
  Runtime.parseMessage ServiceDescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder ServiceDescriptorProtoR ServiceDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "method / " $ do
    x <- Runtime.parseLenDel parseMethodDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "method") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseServiceOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , method: []
    , options: Maybe.Nothing
    }


type MethodDescriptorProtoR =
  { name :: Maybe.Maybe String
  , input_type :: Maybe.Maybe String
  , output_type :: Maybe.Maybe String
  , options :: Maybe.Maybe MethodOptions
  , client_streaming :: Maybe.Maybe Boolean
  , server_streaming :: Maybe.Maybe Boolean
  }
newtype MethodDescriptorProto = MethodDescriptorProto MethodDescriptorProtoR
derive instance genericMethodDescriptorProto :: Generic.Rep.Generic MethodDescriptorProto _
derive instance newtypeMethodDescriptorProto :: Newtype.Newtype MethodDescriptorProto _

putMethodDescriptorProto :: forall m. Effect.MonadEffect m => MethodDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putMethodDescriptorProto (MethodDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.input_type Encode.string
  Runtime.putOptional 3 r.output_type Encode.string
  Runtime.putOptional 4 r.options $ Runtime.putLenDel putMethodOptions
  Runtime.putOptional 5 r.client_streaming Encode.bool
  Runtime.putOptional 6 r.server_streaming Encode.bool

parseMethodDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m MethodDescriptorProto
parseMethodDescriptorProto length = Runtime.label "MethodDescriptorProto / " $
  Runtime.parseMessage MethodDescriptorProto default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder MethodDescriptorProtoR MethodDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "input_type / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "input_type") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "output_type / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "output_type") $ Function.const $ Maybe.Just x
  parseField 4 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseMethodOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "client_streaming / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "client_streaming") $ Function.const $ Maybe.Just x
  parseField 6 Common.VarInt = Runtime.label "server_streaming / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "server_streaming") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: Maybe.Nothing
    , input_type: Maybe.Nothing
    , output_type: Maybe.Nothing
    , options: Maybe.Nothing
    , client_streaming: Maybe.Nothing
    , server_streaming: Maybe.Nothing
    }


type FileOptionsR =
  { java_package :: Maybe.Maybe String
  , java_outer_classname :: Maybe.Maybe String
  , java_multiple_files :: Maybe.Maybe Boolean
  , java_generate_equals_and_hash :: Maybe.Maybe Boolean
  , java_string_check_utf8 :: Maybe.Maybe Boolean
  , optimize_for :: Maybe.Maybe FileOptions_OptimizeMode
  , go_package :: Maybe.Maybe String
  , cc_generic_services :: Maybe.Maybe Boolean
  , java_generic_services :: Maybe.Maybe Boolean
  , py_generic_services :: Maybe.Maybe Boolean
  , php_generic_services :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , cc_enable_arenas :: Maybe.Maybe Boolean
  , objc_class_prefix :: Maybe.Maybe String
  , csharp_namespace :: Maybe.Maybe String
  , swift_prefix :: Maybe.Maybe String
  , php_class_prefix :: Maybe.Maybe String
  , php_namespace :: Maybe.Maybe String
  , php_metadata_namespace :: Maybe.Maybe String
  , ruby_package :: Maybe.Maybe String
  , uninterpreted_option :: Array UninterpretedOption
  }
newtype FileOptions = FileOptions FileOptionsR
derive instance genericFileOptions :: Generic.Rep.Generic FileOptions _
derive instance newtypeFileOptions :: Newtype.Newtype FileOptions _

putFileOptions :: forall m. Effect.MonadEffect m => FileOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putFileOptions (FileOptions r) = do
  Runtime.putOptional 1 r.java_package Encode.string
  Runtime.putOptional 8 r.java_outer_classname Encode.string
  Runtime.putOptional 10 r.java_multiple_files Encode.bool
  Runtime.putOptional 20 r.java_generate_equals_and_hash Encode.bool
  Runtime.putOptional 27 r.java_string_check_utf8 Encode.bool
  Runtime.putOptional 9 r.optimize_for Runtime.putEnum
  Runtime.putOptional 11 r.go_package Encode.string
  Runtime.putOptional 16 r.cc_generic_services Encode.bool
  Runtime.putOptional 17 r.java_generic_services Encode.bool
  Runtime.putOptional 18 r.py_generic_services Encode.bool
  Runtime.putOptional 42 r.php_generic_services Encode.bool
  Runtime.putOptional 23 r.deprecated Encode.bool
  Runtime.putOptional 31 r.cc_enable_arenas Encode.bool
  Runtime.putOptional 36 r.objc_class_prefix Encode.string
  Runtime.putOptional 37 r.csharp_namespace Encode.string
  Runtime.putOptional 39 r.swift_prefix Encode.string
  Runtime.putOptional 40 r.php_class_prefix Encode.string
  Runtime.putOptional 41 r.php_namespace Encode.string
  Runtime.putOptional 44 r.php_metadata_namespace Encode.string
  Runtime.putOptional 45 r.ruby_package Encode.string
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseFileOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FileOptions
parseFileOptions length = Runtime.label "FileOptions / " $
  Runtime.parseMessage FileOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FileOptionsR FileOptionsR)
  parseField 1 Common.LenDel = Runtime.label "java_package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_package") $ Function.const $ Maybe.Just x
  parseField 8 Common.LenDel = Runtime.label "java_outer_classname / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_outer_classname") $ Function.const $ Maybe.Just x
  parseField 10 Common.VarInt = Runtime.label "java_multiple_files / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_multiple_files") $ Function.const $ Maybe.Just x
  parseField 20 Common.VarInt = Runtime.label "java_generate_equals_and_hash / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_generate_equals_and_hash") $ Function.const $ Maybe.Just x
  parseField 27 Common.VarInt = Runtime.label "java_string_check_utf8 / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_string_check_utf8") $ Function.const $ Maybe.Just x
  parseField 9 Common.VarInt = Runtime.label "optimize_for / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "optimize_for") $ Function.const $ Maybe.Just x
  parseField 11 Common.LenDel = Runtime.label "go_package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "go_package") $ Function.const $ Maybe.Just x
  parseField 16 Common.VarInt = Runtime.label "cc_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "cc_generic_services") $ Function.const $ Maybe.Just x
  parseField 17 Common.VarInt = Runtime.label "java_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_generic_services") $ Function.const $ Maybe.Just x
  parseField 18 Common.VarInt = Runtime.label "py_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "py_generic_services") $ Function.const $ Maybe.Just x
  parseField 42 Common.VarInt = Runtime.label "php_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_generic_services") $ Function.const $ Maybe.Just x
  parseField 23 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 31 Common.VarInt = Runtime.label "cc_enable_arenas / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "cc_enable_arenas") $ Function.const $ Maybe.Just x
  parseField 36 Common.LenDel = Runtime.label "objc_class_prefix / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "objc_class_prefix") $ Function.const $ Maybe.Just x
  parseField 37 Common.LenDel = Runtime.label "csharp_namespace / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "csharp_namespace") $ Function.const $ Maybe.Just x
  parseField 39 Common.LenDel = Runtime.label "swift_prefix / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "swift_prefix") $ Function.const $ Maybe.Just x
  parseField 40 Common.LenDel = Runtime.label "php_class_prefix / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_class_prefix") $ Function.const $ Maybe.Just x
  parseField 41 Common.LenDel = Runtime.label "php_namespace / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_namespace") $ Function.const $ Maybe.Just x
  parseField 44 Common.LenDel = Runtime.label "php_metadata_namespace / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_metadata_namespace") $ Function.const $ Maybe.Just x
  parseField 45 Common.LenDel = Runtime.label "ruby_package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "ruby_package") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { java_package: Maybe.Nothing
    , java_outer_classname: Maybe.Nothing
    , java_multiple_files: Maybe.Nothing
    , java_generate_equals_and_hash: Maybe.Nothing
    , java_string_check_utf8: Maybe.Nothing
    , optimize_for: Maybe.Nothing
    , go_package: Maybe.Nothing
    , cc_generic_services: Maybe.Nothing
    , java_generic_services: Maybe.Nothing
    , py_generic_services: Maybe.Nothing
    , php_generic_services: Maybe.Nothing
    , deprecated: Maybe.Nothing
    , cc_enable_arenas: Maybe.Nothing
    , objc_class_prefix: Maybe.Nothing
    , csharp_namespace: Maybe.Nothing
    , swift_prefix: Maybe.Nothing
    , php_class_prefix: Maybe.Nothing
    , php_namespace: Maybe.Nothing
    , php_metadata_namespace: Maybe.Nothing
    , ruby_package: Maybe.Nothing
    , uninterpreted_option: []
    }


type MessageOptionsR =
  { message_set_wire_format :: Maybe.Maybe Boolean
  , no_standard_descriptor_accessor :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , map_entry :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  }
newtype MessageOptions = MessageOptions MessageOptionsR
derive instance genericMessageOptions :: Generic.Rep.Generic MessageOptions _
derive instance newtypeMessageOptions :: Newtype.Newtype MessageOptions _

putMessageOptions :: forall m. Effect.MonadEffect m => MessageOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putMessageOptions (MessageOptions r) = do
  Runtime.putOptional 1 r.message_set_wire_format Encode.bool
  Runtime.putOptional 2 r.no_standard_descriptor_accessor Encode.bool
  Runtime.putOptional 3 r.deprecated Encode.bool
  Runtime.putOptional 7 r.map_entry Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseMessageOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m MessageOptions
parseMessageOptions length = Runtime.label "MessageOptions / " $
  Runtime.parseMessage MessageOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder MessageOptionsR MessageOptionsR)
  parseField 1 Common.VarInt = Runtime.label "message_set_wire_format / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "message_set_wire_format") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "no_standard_descriptor_accessor / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "no_standard_descriptor_accessor") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 7 Common.VarInt = Runtime.label "map_entry / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "map_entry") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { message_set_wire_format: Maybe.Nothing
    , no_standard_descriptor_accessor: Maybe.Nothing
    , deprecated: Maybe.Nothing
    , map_entry: Maybe.Nothing
    , uninterpreted_option: []
    }


type FieldOptionsR =
  { ctype :: Maybe.Maybe FieldOptions_CType
  , packed :: Maybe.Maybe Boolean
  , jstype :: Maybe.Maybe FieldOptions_JSType
  , lazy :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , weak :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  }
newtype FieldOptions = FieldOptions FieldOptionsR
derive instance genericFieldOptions :: Generic.Rep.Generic FieldOptions _
derive instance newtypeFieldOptions :: Newtype.Newtype FieldOptions _

putFieldOptions :: forall m. Effect.MonadEffect m => FieldOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putFieldOptions (FieldOptions r) = do
  Runtime.putOptional 1 r.ctype Runtime.putEnum
  Runtime.putOptional 2 r.packed Encode.bool
  Runtime.putOptional 6 r.jstype Runtime.putEnum
  Runtime.putOptional 5 r.lazy Encode.bool
  Runtime.putOptional 3 r.deprecated Encode.bool
  Runtime.putOptional 10 r.weak Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseFieldOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FieldOptions
parseFieldOptions length = Runtime.label "FieldOptions / " $
  Runtime.parseMessage FieldOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FieldOptionsR FieldOptionsR)
  parseField 1 Common.VarInt = Runtime.label "ctype / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "ctype") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "packed / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "packed") $ Function.const $ Maybe.Just x
  parseField 6 Common.VarInt = Runtime.label "jstype / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "jstype") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "lazy / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "lazy") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 10 Common.VarInt = Runtime.label "weak / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "weak") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { ctype: Maybe.Nothing
    , packed: Maybe.Nothing
    , jstype: Maybe.Nothing
    , lazy: Maybe.Nothing
    , deprecated: Maybe.Nothing
    , weak: Maybe.Nothing
    , uninterpreted_option: []
    }


type OneofOptionsR =
  { uninterpreted_option :: Array UninterpretedOption
  }
newtype OneofOptions = OneofOptions OneofOptionsR
derive instance genericOneofOptions :: Generic.Rep.Generic OneofOptions _
derive instance newtypeOneofOptions :: Newtype.Newtype OneofOptions _

putOneofOptions :: forall m. Effect.MonadEffect m => OneofOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putOneofOptions (OneofOptions r) = do
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseOneofOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m OneofOptions
parseOneofOptions length = Runtime.label "OneofOptions / " $
  Runtime.parseMessage OneofOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder OneofOptionsR OneofOptionsR)
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { uninterpreted_option: []
    }


type EnumOptionsR =
  { allow_alias :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  }
newtype EnumOptions = EnumOptions EnumOptionsR
derive instance genericEnumOptions :: Generic.Rep.Generic EnumOptions _
derive instance newtypeEnumOptions :: Newtype.Newtype EnumOptions _

putEnumOptions :: forall m. Effect.MonadEffect m => EnumOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumOptions (EnumOptions r) = do
  Runtime.putOptional 2 r.allow_alias Encode.bool
  Runtime.putOptional 3 r.deprecated Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseEnumOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumOptions
parseEnumOptions length = Runtime.label "EnumOptions / " $
  Runtime.parseMessage EnumOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumOptionsR EnumOptionsR)
  parseField 2 Common.VarInt = Runtime.label "allow_alias / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "allow_alias") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { allow_alias: Maybe.Nothing
    , deprecated: Maybe.Nothing
    , uninterpreted_option: []
    }


type EnumValueOptionsR =
  { deprecated :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  }
newtype EnumValueOptions = EnumValueOptions EnumValueOptionsR
derive instance genericEnumValueOptions :: Generic.Rep.Generic EnumValueOptions _
derive instance newtypeEnumValueOptions :: Newtype.Newtype EnumValueOptions _

putEnumValueOptions :: forall m. Effect.MonadEffect m => EnumValueOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumValueOptions (EnumValueOptions r) = do
  Runtime.putOptional 1 r.deprecated Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseEnumValueOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumValueOptions
parseEnumValueOptions length = Runtime.label "EnumValueOptions / " $
  Runtime.parseMessage EnumValueOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumValueOptionsR EnumValueOptionsR)
  parseField 1 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { deprecated: Maybe.Nothing
    , uninterpreted_option: []
    }


type ServiceOptionsR =
  { deprecated :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  }
newtype ServiceOptions = ServiceOptions ServiceOptionsR
derive instance genericServiceOptions :: Generic.Rep.Generic ServiceOptions _
derive instance newtypeServiceOptions :: Newtype.Newtype ServiceOptions _

putServiceOptions :: forall m. Effect.MonadEffect m => ServiceOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putServiceOptions (ServiceOptions r) = do
  Runtime.putOptional 33 r.deprecated Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseServiceOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m ServiceOptions
parseServiceOptions length = Runtime.label "ServiceOptions / " $
  Runtime.parseMessage ServiceOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder ServiceOptionsR ServiceOptionsR)
  parseField 33 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { deprecated: Maybe.Nothing
    , uninterpreted_option: []
    }


type MethodOptionsR =
  { deprecated :: Maybe.Maybe Boolean
  , idempotency_level :: Maybe.Maybe MethodOptions_IdempotencyLevel
  , uninterpreted_option :: Array UninterpretedOption
  }
newtype MethodOptions = MethodOptions MethodOptionsR
derive instance genericMethodOptions :: Generic.Rep.Generic MethodOptions _
derive instance newtypeMethodOptions :: Newtype.Newtype MethodOptions _

putMethodOptions :: forall m. Effect.MonadEffect m => MethodOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putMethodOptions (MethodOptions r) = do
  Runtime.putOptional 33 r.deprecated Encode.bool
  Runtime.putOptional 34 r.idempotency_level Runtime.putEnum
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption

parseMethodOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m MethodOptions
parseMethodOptions length = Runtime.label "MethodOptions / " $
  Runtime.parseMessage MethodOptions default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder MethodOptionsR MethodOptionsR)
  parseField 33 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 34 Common.VarInt = Runtime.label "idempotency_level / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "idempotency_level") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { deprecated: Maybe.Nothing
    , idempotency_level: Maybe.Nothing
    , uninterpreted_option: []
    }


type UninterpretedOptionR =
  { name :: Array UninterpretedOption_NamePart
  , identifier_value :: Maybe.Maybe String
  , positive_int_value :: Maybe.Maybe (Long.Long Long.Unsigned)
  , negative_int_value :: Maybe.Maybe (Long.Long Long.Signed)
  , double_value :: Maybe.Maybe Number
  , string_value :: Maybe.Maybe ArrayBuffer.Types.ArrayBuffer
  , aggregate_value :: Maybe.Maybe String
  }
newtype UninterpretedOption = UninterpretedOption UninterpretedOptionR
derive instance genericUninterpretedOption :: Generic.Rep.Generic UninterpretedOption _
derive instance newtypeUninterpretedOption :: Newtype.Newtype UninterpretedOption _

putUninterpretedOption :: forall m. Effect.MonadEffect m => UninterpretedOption -> ArrayBuffer.Builder.PutM m Unit.Unit
putUninterpretedOption (UninterpretedOption r) = do
  Runtime.putRepeated 2 r.name $ Runtime.putLenDel putUninterpretedOption_NamePart
  Runtime.putOptional 3 r.identifier_value Encode.string
  Runtime.putOptional 4 r.positive_int_value Encode.uint64
  Runtime.putOptional 5 r.negative_int_value Encode.int64
  Runtime.putOptional 6 r.double_value Encode.double
  Runtime.putOptional 7 r.string_value Encode.bytes
  Runtime.putOptional 8 r.aggregate_value Encode.string

parseUninterpretedOption :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m UninterpretedOption
parseUninterpretedOption length = Runtime.label "UninterpretedOption / " $
  Runtime.parseMessage UninterpretedOption default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder UninterpretedOptionR UninterpretedOptionR)
  parseField 2 Common.LenDel = Runtime.label "name / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption_NamePart
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "identifier_value / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "identifier_value") $ Function.const $ Maybe.Just x
  parseField 4 Common.VarInt = Runtime.label "positive_int_value / " $ do
    x <- Decode.uint64
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "positive_int_value") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "negative_int_value / " $ do
    x <- Decode.int64
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "negative_int_value") $ Function.const $ Maybe.Just x
  parseField 6 Common.Bits64 = Runtime.label "double_value / " $ do
    x <- Decode.double
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "double_value") $ Function.const $ Maybe.Just x
  parseField 7 Common.LenDel = Runtime.label "string_value / " $ do
    x <- Decode.bytes
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "string_value") $ Function.const $ Maybe.Just x
  parseField 8 Common.LenDel = Runtime.label "aggregate_value / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "aggregate_value") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name: []
    , identifier_value: Maybe.Nothing
    , positive_int_value: Maybe.Nothing
    , negative_int_value: Maybe.Nothing
    , double_value: Maybe.Nothing
    , string_value: Maybe.Nothing
    , aggregate_value: Maybe.Nothing
    }


type UninterpretedOption_NamePartR =
  { name_part :: Maybe.Maybe String
  , is_extension :: Maybe.Maybe Boolean
  }
newtype UninterpretedOption_NamePart = UninterpretedOption_NamePart UninterpretedOption_NamePartR
derive instance genericUninterpretedOption_NamePart :: Generic.Rep.Generic UninterpretedOption_NamePart _
derive instance newtypeUninterpretedOption_NamePart :: Newtype.Newtype UninterpretedOption_NamePart _

putUninterpretedOption_NamePart :: forall m. Effect.MonadEffect m => UninterpretedOption_NamePart -> ArrayBuffer.Builder.PutM m Unit.Unit
putUninterpretedOption_NamePart (UninterpretedOption_NamePart r) = do
  Runtime.putOptional 1 r.name_part Encode.string
  Runtime.putOptional 2 r.is_extension Encode.bool

parseUninterpretedOption_NamePart :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m UninterpretedOption_NamePart
parseUninterpretedOption_NamePart length = Runtime.label "NamePart / " $
  Runtime.parseMessage UninterpretedOption_NamePart default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder UninterpretedOption_NamePartR UninterpretedOption_NamePartR)
  parseField 1 Common.LenDel = Runtime.label "name_part / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name_part") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "is_extension / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "is_extension") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { name_part: Maybe.Nothing
    , is_extension: Maybe.Nothing
    }


type SourceCodeInfoR =
  { location :: Array SourceCodeInfo_Location
  }
newtype SourceCodeInfo = SourceCodeInfo SourceCodeInfoR
derive instance genericSourceCodeInfo :: Generic.Rep.Generic SourceCodeInfo _
derive instance newtypeSourceCodeInfo :: Newtype.Newtype SourceCodeInfo _

putSourceCodeInfo :: forall m. Effect.MonadEffect m => SourceCodeInfo -> ArrayBuffer.Builder.PutM m Unit.Unit
putSourceCodeInfo (SourceCodeInfo r) = do
  Runtime.putRepeated 1 r.location $ Runtime.putLenDel putSourceCodeInfo_Location

parseSourceCodeInfo :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m SourceCodeInfo
parseSourceCodeInfo length = Runtime.label "SourceCodeInfo / " $
  Runtime.parseMessage SourceCodeInfo default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder SourceCodeInfoR SourceCodeInfoR)
  parseField 1 Common.LenDel = Runtime.label "location / " $ do
    x <- Runtime.parseLenDel parseSourceCodeInfo_Location
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "location") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { location: []
    }


type SourceCodeInfo_LocationR =
  { path :: Array Int
  , span :: Array Int
  , leading_comments :: Maybe.Maybe String
  , trailing_comments :: Maybe.Maybe String
  , leading_detached_comments :: Array String
  }
newtype SourceCodeInfo_Location = SourceCodeInfo_Location SourceCodeInfo_LocationR
derive instance genericSourceCodeInfo_Location :: Generic.Rep.Generic SourceCodeInfo_Location _
derive instance newtypeSourceCodeInfo_Location :: Newtype.Newtype SourceCodeInfo_Location _

putSourceCodeInfo_Location :: forall m. Effect.MonadEffect m => SourceCodeInfo_Location -> ArrayBuffer.Builder.PutM m Unit.Unit
putSourceCodeInfo_Location (SourceCodeInfo_Location r) = do
  Runtime.putPacked 1 r.path Encode.int32'
  Runtime.putPacked 2 r.span Encode.int32'
  Runtime.putOptional 3 r.leading_comments Encode.string
  Runtime.putOptional 4 r.trailing_comments Encode.string
  Runtime.putRepeated 6 r.leading_detached_comments Encode.string

parseSourceCodeInfo_Location :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m SourceCodeInfo_Location
parseSourceCodeInfo_Location length = Runtime.label "Location / " $
  Runtime.parseMessage SourceCodeInfo_Location default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder SourceCodeInfo_LocationR SourceCodeInfo_LocationR)
  parseField 1 Common.VarInt = Runtime.label "path / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Array.snoc x
  parseField 1 Common.LenDel = Runtime.label "path / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Semigroup.append x
  parseField 2 Common.VarInt = Runtime.label "span / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "span") $ Function.flip Array.snoc x
  parseField 2 Common.LenDel = Runtime.label "span / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "span") $ Function.flip Semigroup.append x
  parseField 3 Common.LenDel = Runtime.label "leading_comments / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "leading_comments") $ Function.const $ Maybe.Just x
  parseField 4 Common.LenDel = Runtime.label "trailing_comments / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "trailing_comments") $ Function.const $ Maybe.Just x
  parseField 6 Common.LenDel = Runtime.label "leading_detached_comments / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "leading_detached_comments") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { path: []
    , span: []
    , leading_comments: Maybe.Nothing
    , trailing_comments: Maybe.Nothing
    , leading_detached_comments: []
    }


type GeneratedCodeInfoR =
  { annotation :: Array GeneratedCodeInfo_Annotation
  }
newtype GeneratedCodeInfo = GeneratedCodeInfo GeneratedCodeInfoR
derive instance genericGeneratedCodeInfo :: Generic.Rep.Generic GeneratedCodeInfo _
derive instance newtypeGeneratedCodeInfo :: Newtype.Newtype GeneratedCodeInfo _

putGeneratedCodeInfo :: forall m. Effect.MonadEffect m => GeneratedCodeInfo -> ArrayBuffer.Builder.PutM m Unit.Unit
putGeneratedCodeInfo (GeneratedCodeInfo r) = do
  Runtime.putRepeated 1 r.annotation $ Runtime.putLenDel putGeneratedCodeInfo_Annotation

parseGeneratedCodeInfo :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m GeneratedCodeInfo
parseGeneratedCodeInfo length = Runtime.label "GeneratedCodeInfo / " $
  Runtime.parseMessage GeneratedCodeInfo default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder GeneratedCodeInfoR GeneratedCodeInfoR)
  parseField 1 Common.LenDel = Runtime.label "annotation / " $ do
    x <- Runtime.parseLenDel parseGeneratedCodeInfo_Annotation
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "annotation") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { annotation: []
    }


type GeneratedCodeInfo_AnnotationR =
  { path :: Array Int
  , source_file :: Maybe.Maybe String
  , begin :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  }
newtype GeneratedCodeInfo_Annotation = GeneratedCodeInfo_Annotation GeneratedCodeInfo_AnnotationR
derive instance genericGeneratedCodeInfo_Annotation :: Generic.Rep.Generic GeneratedCodeInfo_Annotation _
derive instance newtypeGeneratedCodeInfo_Annotation :: Newtype.Newtype GeneratedCodeInfo_Annotation _

putGeneratedCodeInfo_Annotation :: forall m. Effect.MonadEffect m => GeneratedCodeInfo_Annotation -> ArrayBuffer.Builder.PutM m Unit.Unit
putGeneratedCodeInfo_Annotation (GeneratedCodeInfo_Annotation r) = do
  Runtime.putPacked 1 r.path Encode.int32'
  Runtime.putOptional 2 r.source_file Encode.string
  Runtime.putOptional 3 r.begin Encode.int32
  Runtime.putOptional 4 r.end Encode.int32

parseGeneratedCodeInfo_Annotation :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m GeneratedCodeInfo_Annotation
parseGeneratedCodeInfo_Annotation length = Runtime.label "Annotation / " $
  Runtime.parseMessage GeneratedCodeInfo_Annotation default parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder GeneratedCodeInfo_AnnotationR GeneratedCodeInfo_AnnotationR)
  parseField 1 Common.VarInt = Runtime.label "path / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Array.snoc x
  parseField 1 Common.LenDel = Runtime.label "path / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Semigroup.append x
  parseField 2 Common.LenDel = Runtime.label "source_file / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "source_file") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "begin / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "begin") $ Function.const $ Maybe.Just x
  parseField 4 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.label ("Unknown " <> show wireType <> " " <> show fieldNumber <> " / ") $
    Runtime.parseFieldUnknown wireType
  default =
    { path: []
    , source_file: Maybe.Nothing
    , begin: Maybe.Nothing
    , end: Maybe.Nothing
    }


data FieldDescriptorProto_Type
  = FieldDescriptorProto_Type_TYPE_DOUBLE
  | FieldDescriptorProto_Type_TYPE_FLOAT
  | FieldDescriptorProto_Type_TYPE_INT64
  | FieldDescriptorProto_Type_TYPE_UINT64
  | FieldDescriptorProto_Type_TYPE_INT32
  | FieldDescriptorProto_Type_TYPE_FIXED64
  | FieldDescriptorProto_Type_TYPE_FIXED32
  | FieldDescriptorProto_Type_TYPE_BOOL
  | FieldDescriptorProto_Type_TYPE_STRING
  | FieldDescriptorProto_Type_TYPE_GROUP
  | FieldDescriptorProto_Type_TYPE_MESSAGE
  | FieldDescriptorProto_Type_TYPE_BYTES
  | FieldDescriptorProto_Type_TYPE_UINT32
  | FieldDescriptorProto_Type_TYPE_ENUM
  | FieldDescriptorProto_Type_TYPE_SFIXED32
  | FieldDescriptorProto_Type_TYPE_SFIXED64
  | FieldDescriptorProto_Type_TYPE_SINT32
  | FieldDescriptorProto_Type_TYPE_SINT64
derive instance genericFieldDescriptorProto_Type :: Generic.Rep.Generic FieldDescriptorProto_Type _
derive instance eqFieldDescriptorProto_Type :: Eq.Eq FieldDescriptorProto_Type
instance showFieldDescriptorProto_Type :: Show.Show FieldDescriptorProto_Type where show = Generic.Rep.Show.genericShow
instance ordFieldDescriptorProto_Type :: Ord.Ord FieldDescriptorProto_Type where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldDescriptorProto_Type :: Bounded.Bounded FieldDescriptorProto_Type
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldDescriptorProto_Type :: Enum.Enum FieldDescriptorProto_Type
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldDescriptorProto_Type :: Enum.BoundedEnum FieldDescriptorProto_Type
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 1 = Maybe.Just FieldDescriptorProto_Type_TYPE_DOUBLE
  toEnum 2 = Maybe.Just FieldDescriptorProto_Type_TYPE_FLOAT
  toEnum 3 = Maybe.Just FieldDescriptorProto_Type_TYPE_INT64
  toEnum 4 = Maybe.Just FieldDescriptorProto_Type_TYPE_UINT64
  toEnum 5 = Maybe.Just FieldDescriptorProto_Type_TYPE_INT32
  toEnum 6 = Maybe.Just FieldDescriptorProto_Type_TYPE_FIXED64
  toEnum 7 = Maybe.Just FieldDescriptorProto_Type_TYPE_FIXED32
  toEnum 8 = Maybe.Just FieldDescriptorProto_Type_TYPE_BOOL
  toEnum 9 = Maybe.Just FieldDescriptorProto_Type_TYPE_STRING
  toEnum 10 = Maybe.Just FieldDescriptorProto_Type_TYPE_GROUP
  toEnum 11 = Maybe.Just FieldDescriptorProto_Type_TYPE_MESSAGE
  toEnum 12 = Maybe.Just FieldDescriptorProto_Type_TYPE_BYTES
  toEnum 13 = Maybe.Just FieldDescriptorProto_Type_TYPE_UINT32
  toEnum 14 = Maybe.Just FieldDescriptorProto_Type_TYPE_ENUM
  toEnum 15 = Maybe.Just FieldDescriptorProto_Type_TYPE_SFIXED32
  toEnum 16 = Maybe.Just FieldDescriptorProto_Type_TYPE_SFIXED64
  toEnum 17 = Maybe.Just FieldDescriptorProto_Type_TYPE_SINT32
  toEnum 18 = Maybe.Just FieldDescriptorProto_Type_TYPE_SINT64
  toEnum _ = Maybe.Nothing
  fromEnum FieldDescriptorProto_Type_TYPE_DOUBLE = 1
  fromEnum FieldDescriptorProto_Type_TYPE_FLOAT = 2
  fromEnum FieldDescriptorProto_Type_TYPE_INT64 = 3
  fromEnum FieldDescriptorProto_Type_TYPE_UINT64 = 4
  fromEnum FieldDescriptorProto_Type_TYPE_INT32 = 5
  fromEnum FieldDescriptorProto_Type_TYPE_FIXED64 = 6
  fromEnum FieldDescriptorProto_Type_TYPE_FIXED32 = 7
  fromEnum FieldDescriptorProto_Type_TYPE_BOOL = 8
  fromEnum FieldDescriptorProto_Type_TYPE_STRING = 9
  fromEnum FieldDescriptorProto_Type_TYPE_GROUP = 10
  fromEnum FieldDescriptorProto_Type_TYPE_MESSAGE = 11
  fromEnum FieldDescriptorProto_Type_TYPE_BYTES = 12
  fromEnum FieldDescriptorProto_Type_TYPE_UINT32 = 13
  fromEnum FieldDescriptorProto_Type_TYPE_ENUM = 14
  fromEnum FieldDescriptorProto_Type_TYPE_SFIXED32 = 15
  fromEnum FieldDescriptorProto_Type_TYPE_SFIXED64 = 16
  fromEnum FieldDescriptorProto_Type_TYPE_SINT32 = 17
  fromEnum FieldDescriptorProto_Type_TYPE_SINT64 = 18

data FieldDescriptorProto_Label
  = FieldDescriptorProto_Label_LABEL_OPTIONAL
  | FieldDescriptorProto_Label_LABEL_REQUIRED
  | FieldDescriptorProto_Label_LABEL_REPEATED
derive instance genericFieldDescriptorProto_Label :: Generic.Rep.Generic FieldDescriptorProto_Label _
derive instance eqFieldDescriptorProto_Label :: Eq.Eq FieldDescriptorProto_Label
instance showFieldDescriptorProto_Label :: Show.Show FieldDescriptorProto_Label where show = Generic.Rep.Show.genericShow
instance ordFieldDescriptorProto_Label :: Ord.Ord FieldDescriptorProto_Label where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldDescriptorProto_Label :: Bounded.Bounded FieldDescriptorProto_Label
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldDescriptorProto_Label :: Enum.Enum FieldDescriptorProto_Label
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldDescriptorProto_Label :: Enum.BoundedEnum FieldDescriptorProto_Label
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 1 = Maybe.Just FieldDescriptorProto_Label_LABEL_OPTIONAL
  toEnum 2 = Maybe.Just FieldDescriptorProto_Label_LABEL_REQUIRED
  toEnum 3 = Maybe.Just FieldDescriptorProto_Label_LABEL_REPEATED
  toEnum _ = Maybe.Nothing
  fromEnum FieldDescriptorProto_Label_LABEL_OPTIONAL = 1
  fromEnum FieldDescriptorProto_Label_LABEL_REQUIRED = 2
  fromEnum FieldDescriptorProto_Label_LABEL_REPEATED = 3

data FileOptions_OptimizeMode
  = FileOptions_OptimizeMode_SPEED
  | FileOptions_OptimizeMode_CODE_SIZE
  | FileOptions_OptimizeMode_LITE_RUNTIME
derive instance genericFileOptions_OptimizeMode :: Generic.Rep.Generic FileOptions_OptimizeMode _
derive instance eqFileOptions_OptimizeMode :: Eq.Eq FileOptions_OptimizeMode
instance showFileOptions_OptimizeMode :: Show.Show FileOptions_OptimizeMode where show = Generic.Rep.Show.genericShow
instance ordFileOptions_OptimizeMode :: Ord.Ord FileOptions_OptimizeMode where compare = Generic.Rep.Ord.genericCompare
instance boundedFileOptions_OptimizeMode :: Bounded.Bounded FileOptions_OptimizeMode
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFileOptions_OptimizeMode :: Enum.Enum FileOptions_OptimizeMode
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFileOptions_OptimizeMode :: Enum.BoundedEnum FileOptions_OptimizeMode
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 1 = Maybe.Just FileOptions_OptimizeMode_SPEED
  toEnum 2 = Maybe.Just FileOptions_OptimizeMode_CODE_SIZE
  toEnum 3 = Maybe.Just FileOptions_OptimizeMode_LITE_RUNTIME
  toEnum _ = Maybe.Nothing
  fromEnum FileOptions_OptimizeMode_SPEED = 1
  fromEnum FileOptions_OptimizeMode_CODE_SIZE = 2
  fromEnum FileOptions_OptimizeMode_LITE_RUNTIME = 3

data FieldOptions_CType
  = FieldOptions_CType_STRING
  | FieldOptions_CType_CORD
  | FieldOptions_CType_STRING_PIECE
derive instance genericFieldOptions_CType :: Generic.Rep.Generic FieldOptions_CType _
derive instance eqFieldOptions_CType :: Eq.Eq FieldOptions_CType
instance showFieldOptions_CType :: Show.Show FieldOptions_CType where show = Generic.Rep.Show.genericShow
instance ordFieldOptions_CType :: Ord.Ord FieldOptions_CType where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldOptions_CType :: Bounded.Bounded FieldOptions_CType
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldOptions_CType :: Enum.Enum FieldOptions_CType
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldOptions_CType :: Enum.BoundedEnum FieldOptions_CType
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 0 = Maybe.Just FieldOptions_CType_STRING
  toEnum 1 = Maybe.Just FieldOptions_CType_CORD
  toEnum 2 = Maybe.Just FieldOptions_CType_STRING_PIECE
  toEnum _ = Maybe.Nothing
  fromEnum FieldOptions_CType_STRING = 0
  fromEnum FieldOptions_CType_CORD = 1
  fromEnum FieldOptions_CType_STRING_PIECE = 2

data FieldOptions_JSType
  = FieldOptions_JSType_JS_NORMAL
  | FieldOptions_JSType_JS_STRING
  | FieldOptions_JSType_JS_NUMBER
derive instance genericFieldOptions_JSType :: Generic.Rep.Generic FieldOptions_JSType _
derive instance eqFieldOptions_JSType :: Eq.Eq FieldOptions_JSType
instance showFieldOptions_JSType :: Show.Show FieldOptions_JSType where show = Generic.Rep.Show.genericShow
instance ordFieldOptions_JSType :: Ord.Ord FieldOptions_JSType where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldOptions_JSType :: Bounded.Bounded FieldOptions_JSType
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldOptions_JSType :: Enum.Enum FieldOptions_JSType
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldOptions_JSType :: Enum.BoundedEnum FieldOptions_JSType
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 0 = Maybe.Just FieldOptions_JSType_JS_NORMAL
  toEnum 1 = Maybe.Just FieldOptions_JSType_JS_STRING
  toEnum 2 = Maybe.Just FieldOptions_JSType_JS_NUMBER
  toEnum _ = Maybe.Nothing
  fromEnum FieldOptions_JSType_JS_NORMAL = 0
  fromEnum FieldOptions_JSType_JS_STRING = 1
  fromEnum FieldOptions_JSType_JS_NUMBER = 2

data MethodOptions_IdempotencyLevel
  = MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN
  | MethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS
  | MethodOptions_IdempotencyLevel_IDEMPOTENT
derive instance genericMethodOptions_IdempotencyLevel :: Generic.Rep.Generic MethodOptions_IdempotencyLevel _
derive instance eqMethodOptions_IdempotencyLevel :: Eq.Eq MethodOptions_IdempotencyLevel
instance showMethodOptions_IdempotencyLevel :: Show.Show MethodOptions_IdempotencyLevel where show = Generic.Rep.Show.genericShow
instance ordMethodOptions_IdempotencyLevel :: Ord.Ord MethodOptions_IdempotencyLevel where compare = Generic.Rep.Ord.genericCompare
instance boundedMethodOptions_IdempotencyLevel :: Bounded.Bounded MethodOptions_IdempotencyLevel
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumMethodOptions_IdempotencyLevel :: Enum.Enum MethodOptions_IdempotencyLevel
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumMethodOptions_IdempotencyLevel :: Enum.BoundedEnum MethodOptions_IdempotencyLevel
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 0 = Maybe.Just MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN
  toEnum 1 = Maybe.Just MethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS
  toEnum 2 = Maybe.Just MethodOptions_IdempotencyLevel_IDEMPOTENT
  toEnum _ = Maybe.Nothing
  fromEnum MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN = 0
  fromEnum MethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS = 1
  fromEnum MethodOptions_IdempotencyLevel_IDEMPOTENT = 2

