-- | Generated by __purescript-protobuf__ from file `google/protobuf/descriptor.proto`
module Google.Protobuf.Descriptor
( FileDescriptorSet(..), FileDescriptorSetRow, FileDescriptorSetR, parseFileDescriptorSet, putFileDescriptorSet, defaultFileDescriptorSet, mkFileDescriptorSet
, FileDescriptorProto(..), FileDescriptorProtoRow, FileDescriptorProtoR, parseFileDescriptorProto, putFileDescriptorProto, defaultFileDescriptorProto, mkFileDescriptorProto
, DescriptorProto(..), DescriptorProtoRow, DescriptorProtoR, parseDescriptorProto, putDescriptorProto, defaultDescriptorProto, mkDescriptorProto
, DescriptorProto_ExtensionRange(..), DescriptorProto_ExtensionRangeRow, DescriptorProto_ExtensionRangeR, parseDescriptorProto_ExtensionRange, putDescriptorProto_ExtensionRange, defaultDescriptorProto_ExtensionRange, mkDescriptorProto_ExtensionRange
, DescriptorProto_ReservedRange(..), DescriptorProto_ReservedRangeRow, DescriptorProto_ReservedRangeR, parseDescriptorProto_ReservedRange, putDescriptorProto_ReservedRange, defaultDescriptorProto_ReservedRange, mkDescriptorProto_ReservedRange
, ExtensionRangeOptions(..), ExtensionRangeOptionsRow, ExtensionRangeOptionsR, parseExtensionRangeOptions, putExtensionRangeOptions, defaultExtensionRangeOptions, mkExtensionRangeOptions
, FieldDescriptorProto(..), FieldDescriptorProtoRow, FieldDescriptorProtoR, parseFieldDescriptorProto, putFieldDescriptorProto, defaultFieldDescriptorProto, mkFieldDescriptorProto
, OneofDescriptorProto(..), OneofDescriptorProtoRow, OneofDescriptorProtoR, parseOneofDescriptorProto, putOneofDescriptorProto, defaultOneofDescriptorProto, mkOneofDescriptorProto
, EnumDescriptorProto(..), EnumDescriptorProtoRow, EnumDescriptorProtoR, parseEnumDescriptorProto, putEnumDescriptorProto, defaultEnumDescriptorProto, mkEnumDescriptorProto
, EnumDescriptorProto_EnumReservedRange(..), EnumDescriptorProto_EnumReservedRangeRow, EnumDescriptorProto_EnumReservedRangeR, parseEnumDescriptorProto_EnumReservedRange, putEnumDescriptorProto_EnumReservedRange, defaultEnumDescriptorProto_EnumReservedRange, mkEnumDescriptorProto_EnumReservedRange
, EnumValueDescriptorProto(..), EnumValueDescriptorProtoRow, EnumValueDescriptorProtoR, parseEnumValueDescriptorProto, putEnumValueDescriptorProto, defaultEnumValueDescriptorProto, mkEnumValueDescriptorProto
, ServiceDescriptorProto(..), ServiceDescriptorProtoRow, ServiceDescriptorProtoR, parseServiceDescriptorProto, putServiceDescriptorProto, defaultServiceDescriptorProto, mkServiceDescriptorProto
, MethodDescriptorProto(..), MethodDescriptorProtoRow, MethodDescriptorProtoR, parseMethodDescriptorProto, putMethodDescriptorProto, defaultMethodDescriptorProto, mkMethodDescriptorProto
, FileOptions(..), FileOptionsRow, FileOptionsR, parseFileOptions, putFileOptions, defaultFileOptions, mkFileOptions
, MessageOptions(..), MessageOptionsRow, MessageOptionsR, parseMessageOptions, putMessageOptions, defaultMessageOptions, mkMessageOptions
, FieldOptions(..), FieldOptionsRow, FieldOptionsR, parseFieldOptions, putFieldOptions, defaultFieldOptions, mkFieldOptions
, OneofOptions(..), OneofOptionsRow, OneofOptionsR, parseOneofOptions, putOneofOptions, defaultOneofOptions, mkOneofOptions
, EnumOptions(..), EnumOptionsRow, EnumOptionsR, parseEnumOptions, putEnumOptions, defaultEnumOptions, mkEnumOptions
, EnumValueOptions(..), EnumValueOptionsRow, EnumValueOptionsR, parseEnumValueOptions, putEnumValueOptions, defaultEnumValueOptions, mkEnumValueOptions
, ServiceOptions(..), ServiceOptionsRow, ServiceOptionsR, parseServiceOptions, putServiceOptions, defaultServiceOptions, mkServiceOptions
, MethodOptions(..), MethodOptionsRow, MethodOptionsR, parseMethodOptions, putMethodOptions, defaultMethodOptions, mkMethodOptions
, UninterpretedOption(..), UninterpretedOptionRow, UninterpretedOptionR, parseUninterpretedOption, putUninterpretedOption, defaultUninterpretedOption, mkUninterpretedOption
, UninterpretedOption_NamePart(..), UninterpretedOption_NamePartRow, UninterpretedOption_NamePartR, parseUninterpretedOption_NamePart, putUninterpretedOption_NamePart, defaultUninterpretedOption_NamePart, mkUninterpretedOption_NamePart
, SourceCodeInfo(..), SourceCodeInfoRow, SourceCodeInfoR, parseSourceCodeInfo, putSourceCodeInfo, defaultSourceCodeInfo, mkSourceCodeInfo
, SourceCodeInfo_Location(..), SourceCodeInfo_LocationRow, SourceCodeInfo_LocationR, parseSourceCodeInfo_Location, putSourceCodeInfo_Location, defaultSourceCodeInfo_Location, mkSourceCodeInfo_Location
, GeneratedCodeInfo(..), GeneratedCodeInfoRow, GeneratedCodeInfoR, parseGeneratedCodeInfo, putGeneratedCodeInfo, defaultGeneratedCodeInfo, mkGeneratedCodeInfo
, GeneratedCodeInfo_Annotation(..), GeneratedCodeInfo_AnnotationRow, GeneratedCodeInfo_AnnotationR, parseGeneratedCodeInfo_Annotation, putGeneratedCodeInfo_Annotation, defaultGeneratedCodeInfo_Annotation, mkGeneratedCodeInfo_Annotation
, FieldDescriptorProto_Type(..)
, FieldDescriptorProto_Label(..)
, FileOptions_OptimizeMode(..)
, FieldOptions_CType(..)
, FieldOptions_JSType(..)
, MethodOptions_IdempotencyLevel(..)
)
where

import Prelude
import Effect.Class as Effect
import Record.Builder as Record.Builder
import Data.Array as Array
import Data.Bounded as Bounded
import Data.Enum as Enum
import Data.Eq as Eq
import Data.Function as Function
import Data.Float32 as Float32
import Data.Show as Show
import Data.Ord as Ord
import Data.Maybe as Maybe
import Data.Newtype as Newtype
import Data.Generic.Rep as Generic.Rep
import Data.Generic.Rep.Show as Generic.Rep.Show
import Data.Generic.Rep.Bounded as Generic.Rep.Bounded
import Data.Generic.Rep.Enum as Generic.Rep.Enum
import Data.Generic.Rep.Ord as Generic.Rep.Ord
import Data.Semigroup as Semigroup
import Data.Symbol as Symbol
import Record as Record
import Data.Traversable as Traversable
import Data.UInt as UInt
import Data.Unit as Unit
import Prim.Row as Prim.Row
import Data.Long.Internal as Long
import Text.Parsing.Parser as Parser
import Data.ArrayBuffer.Builder as ArrayBuffer.Builder
import Data.ArrayBuffer.Types as ArrayBuffer.Types
import Protobuf.Common as Common
import Protobuf.Decode as Decode
import Protobuf.Encode as Encode
import Protobuf.Runtime as Runtime




type FileDescriptorSetRow =
  ( file :: Array FileDescriptorProto
  , __unknown_fields :: Array Runtime.UnknownField
  )
type FileDescriptorSetR = Record FileDescriptorSetRow
newtype FileDescriptorSet = FileDescriptorSet FileDescriptorSetR
derive instance genericFileDescriptorSet :: Generic.Rep.Generic FileDescriptorSet _
derive instance newtypeFileDescriptorSet :: Newtype.Newtype FileDescriptorSet _
derive instance eqFileDescriptorSet :: Eq.Eq FileDescriptorSet
instance showFileDescriptorSet :: Show.Show FileDescriptorSet where show x = Generic.Rep.Show.genericShow x

putFileDescriptorSet :: forall m. Effect.MonadEffect m => FileDescriptorSet -> ArrayBuffer.Builder.PutM m Unit.Unit
putFileDescriptorSet (FileDescriptorSet r) = do
  Runtime.putRepeated 1 r.file $ Runtime.putLenDel putFileDescriptorProto
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseFileDescriptorSet :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FileDescriptorSet
parseFileDescriptorSet length = Runtime.label "FileDescriptorSet / " $
  Runtime.parseMessage FileDescriptorSet defaultFileDescriptorSet parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FileDescriptorSetR FileDescriptorSetR)
  parseField 1 Common.LenDel = Runtime.label "file / " $ do
    x <- Runtime.parseLenDel parseFileDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "file") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultFileDescriptorSet :: FileDescriptorSetR
defaultFileDescriptorSet =
  { file: []
  , __unknown_fields: []
  }

mkFileDescriptorSet :: forall r1 r3. Prim.Row.Union r1 FileDescriptorSetRow r3 => Prim.Row.Nub r3 FileDescriptorSetRow => Record r1 -> FileDescriptorSet
mkFileDescriptorSet r = FileDescriptorSet $ Record.merge r defaultFileDescriptorSet


type FileDescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , package :: Maybe.Maybe String
  , dependency :: Array String
  , public_dependency :: Array Int
  , weak_dependency :: Array Int
  , message_type :: Array DescriptorProto
  , enum_type :: Array EnumDescriptorProto
  , service :: Array ServiceDescriptorProto
  , extension :: Array FieldDescriptorProto
  , options :: Maybe.Maybe FileOptions
  , source_code_info :: Maybe.Maybe SourceCodeInfo
  , syntax :: Maybe.Maybe String
  , __unknown_fields :: Array Runtime.UnknownField
  )
type FileDescriptorProtoR = Record FileDescriptorProtoRow
newtype FileDescriptorProto = FileDescriptorProto FileDescriptorProtoR
derive instance genericFileDescriptorProto :: Generic.Rep.Generic FileDescriptorProto _
derive instance newtypeFileDescriptorProto :: Newtype.Newtype FileDescriptorProto _
derive instance eqFileDescriptorProto :: Eq.Eq FileDescriptorProto
instance showFileDescriptorProto :: Show.Show FileDescriptorProto where show x = Generic.Rep.Show.genericShow x

putFileDescriptorProto :: forall m. Effect.MonadEffect m => FileDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putFileDescriptorProto (FileDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.package Encode.string
  Runtime.putRepeated 3 r.dependency Encode.string
  Runtime.putPacked 10 r.public_dependency Encode.int32'
  Runtime.putPacked 11 r.weak_dependency Encode.int32'
  Runtime.putRepeated 4 r.message_type $ Runtime.putLenDel putDescriptorProto
  Runtime.putRepeated 5 r.enum_type $ Runtime.putLenDel putEnumDescriptorProto
  Runtime.putRepeated 6 r.service $ Runtime.putLenDel putServiceDescriptorProto
  Runtime.putRepeated 7 r.extension $ Runtime.putLenDel putFieldDescriptorProto
  Runtime.putOptional 8 r.options $ Runtime.putLenDel putFileOptions
  Runtime.putOptional 9 r.source_code_info $ Runtime.putLenDel putSourceCodeInfo
  Runtime.putOptional 12 r.syntax Encode.string
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseFileDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FileDescriptorProto
parseFileDescriptorProto length = Runtime.label "FileDescriptorProto / " $
  Runtime.parseMessage FileDescriptorProto defaultFileDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FileDescriptorProtoR FileDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "package") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "dependency / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "dependency") $ Function.flip Array.snoc x
  parseField 10 Common.VarInt = Runtime.label "public_dependency / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "public_dependency") $ Function.flip Array.snoc x
  parseField 10 Common.LenDel = Runtime.label "public_dependency / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "public_dependency") $ Function.flip Semigroup.append x
  parseField 11 Common.VarInt = Runtime.label "weak_dependency / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "weak_dependency") $ Function.flip Array.snoc x
  parseField 11 Common.LenDel = Runtime.label "weak_dependency / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "weak_dependency") $ Function.flip Semigroup.append x
  parseField 4 Common.LenDel = Runtime.label "message_type / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "message_type") $ Function.flip Array.snoc x
  parseField 5 Common.LenDel = Runtime.label "enum_type / " $ do
    x <- Runtime.parseLenDel parseEnumDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "enum_type") $ Function.flip Array.snoc x
  parseField 6 Common.LenDel = Runtime.label "service / " $ do
    x <- Runtime.parseLenDel parseServiceDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "service") $ Function.flip Array.snoc x
  parseField 7 Common.LenDel = Runtime.label "extension / " $ do
    x <- Runtime.parseLenDel parseFieldDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extension") $ Function.flip Array.snoc x
  parseField 8 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseFileOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 9 Common.LenDel = Runtime.label "source_code_info / " $ do
    x <- Runtime.parseLenDel parseSourceCodeInfo
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "source_code_info") $ Function.const $ Maybe.Just x
  parseField 12 Common.LenDel = Runtime.label "syntax / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "syntax") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultFileDescriptorProto :: FileDescriptorProtoR
defaultFileDescriptorProto =
  { name: Maybe.Nothing
  , package: Maybe.Nothing
  , dependency: []
  , public_dependency: []
  , weak_dependency: []
  , message_type: []
  , enum_type: []
  , service: []
  , extension: []
  , options: Maybe.Nothing
  , source_code_info: Maybe.Nothing
  , syntax: Maybe.Nothing
  , __unknown_fields: []
  }

mkFileDescriptorProto :: forall r1 r3. Prim.Row.Union r1 FileDescriptorProtoRow r3 => Prim.Row.Nub r3 FileDescriptorProtoRow => Record r1 -> FileDescriptorProto
mkFileDescriptorProto r = FileDescriptorProto $ Record.merge r defaultFileDescriptorProto


type DescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , field :: Array FieldDescriptorProto
  , extension :: Array FieldDescriptorProto
  , nested_type :: Array DescriptorProto
  , enum_type :: Array EnumDescriptorProto
  , extension_range :: Array DescriptorProto_ExtensionRange
  , oneof_decl :: Array OneofDescriptorProto
  , options :: Maybe.Maybe MessageOptions
  , reserved_range :: Array DescriptorProto_ReservedRange
  , reserved_name :: Array String
  , __unknown_fields :: Array Runtime.UnknownField
  )
type DescriptorProtoR = Record DescriptorProtoRow
newtype DescriptorProto = DescriptorProto DescriptorProtoR
derive instance genericDescriptorProto :: Generic.Rep.Generic DescriptorProto _
derive instance newtypeDescriptorProto :: Newtype.Newtype DescriptorProto _
derive instance eqDescriptorProto :: Eq.Eq DescriptorProto
instance showDescriptorProto :: Show.Show DescriptorProto where show x = Generic.Rep.Show.genericShow x

putDescriptorProto :: forall m. Effect.MonadEffect m => DescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putDescriptorProto (DescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putRepeated 2 r.field $ Runtime.putLenDel putFieldDescriptorProto
  Runtime.putRepeated 6 r.extension $ Runtime.putLenDel putFieldDescriptorProto
  Runtime.putRepeated 3 r.nested_type $ Runtime.putLenDel putDescriptorProto
  Runtime.putRepeated 4 r.enum_type $ Runtime.putLenDel putEnumDescriptorProto
  Runtime.putRepeated 5 r.extension_range $ Runtime.putLenDel putDescriptorProto_ExtensionRange
  Runtime.putRepeated 8 r.oneof_decl $ Runtime.putLenDel putOneofDescriptorProto
  Runtime.putOptional 7 r.options $ Runtime.putLenDel putMessageOptions
  Runtime.putRepeated 9 r.reserved_range $ Runtime.putLenDel putDescriptorProto_ReservedRange
  Runtime.putRepeated 10 r.reserved_name Encode.string
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m DescriptorProto
parseDescriptorProto length = Runtime.label "DescriptorProto / " $
  Runtime.parseMessage DescriptorProto defaultDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder DescriptorProtoR DescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "field / " $ do
    x <- Runtime.parseLenDel parseFieldDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "field") $ Function.flip Array.snoc x
  parseField 6 Common.LenDel = Runtime.label "extension / " $ do
    x <- Runtime.parseLenDel parseFieldDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extension") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "nested_type / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "nested_type") $ Function.flip Array.snoc x
  parseField 4 Common.LenDel = Runtime.label "enum_type / " $ do
    x <- Runtime.parseLenDel parseEnumDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "enum_type") $ Function.flip Array.snoc x
  parseField 5 Common.LenDel = Runtime.label "extension_range / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto_ExtensionRange
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extension_range") $ Function.flip Array.snoc x
  parseField 8 Common.LenDel = Runtime.label "oneof_decl / " $ do
    x <- Runtime.parseLenDel parseOneofDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "oneof_decl") $ Function.flip Array.snoc x
  parseField 7 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseMessageOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 9 Common.LenDel = Runtime.label "reserved_range / " $ do
    x <- Runtime.parseLenDel parseDescriptorProto_ReservedRange
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_range") $ Function.flip Array.snoc x
  parseField 10 Common.LenDel = Runtime.label "reserved_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_name") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultDescriptorProto :: DescriptorProtoR
defaultDescriptorProto =
  { name: Maybe.Nothing
  , field: []
  , extension: []
  , nested_type: []
  , enum_type: []
  , extension_range: []
  , oneof_decl: []
  , options: Maybe.Nothing
  , reserved_range: []
  , reserved_name: []
  , __unknown_fields: []
  }

mkDescriptorProto :: forall r1 r3. Prim.Row.Union r1 DescriptorProtoRow r3 => Prim.Row.Nub r3 DescriptorProtoRow => Record r1 -> DescriptorProto
mkDescriptorProto r = DescriptorProto $ Record.merge r defaultDescriptorProto


type DescriptorProto_ExtensionRangeRow =
  ( start :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  , options :: Maybe.Maybe ExtensionRangeOptions
  , __unknown_fields :: Array Runtime.UnknownField
  )
type DescriptorProto_ExtensionRangeR = Record DescriptorProto_ExtensionRangeRow
newtype DescriptorProto_ExtensionRange = DescriptorProto_ExtensionRange DescriptorProto_ExtensionRangeR
derive instance genericDescriptorProto_ExtensionRange :: Generic.Rep.Generic DescriptorProto_ExtensionRange _
derive instance newtypeDescriptorProto_ExtensionRange :: Newtype.Newtype DescriptorProto_ExtensionRange _
derive instance eqDescriptorProto_ExtensionRange :: Eq.Eq DescriptorProto_ExtensionRange
instance showDescriptorProto_ExtensionRange :: Show.Show DescriptorProto_ExtensionRange where show x = Generic.Rep.Show.genericShow x

putDescriptorProto_ExtensionRange :: forall m. Effect.MonadEffect m => DescriptorProto_ExtensionRange -> ArrayBuffer.Builder.PutM m Unit.Unit
putDescriptorProto_ExtensionRange (DescriptorProto_ExtensionRange r) = do
  Runtime.putOptional 1 r.start Encode.int32
  Runtime.putOptional 2 r.end Encode.int32
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putExtensionRangeOptions
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseDescriptorProto_ExtensionRange :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m DescriptorProto_ExtensionRange
parseDescriptorProto_ExtensionRange length = Runtime.label "ExtensionRange / " $
  Runtime.parseMessage DescriptorProto_ExtensionRange defaultDescriptorProto_ExtensionRange parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder DescriptorProto_ExtensionRangeR DescriptorProto_ExtensionRangeR)
  parseField 1 Common.VarInt = Runtime.label "start / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "start") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseExtensionRangeOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultDescriptorProto_ExtensionRange :: DescriptorProto_ExtensionRangeR
defaultDescriptorProto_ExtensionRange =
  { start: Maybe.Nothing
  , end: Maybe.Nothing
  , options: Maybe.Nothing
  , __unknown_fields: []
  }

mkDescriptorProto_ExtensionRange :: forall r1 r3. Prim.Row.Union r1 DescriptorProto_ExtensionRangeRow r3 => Prim.Row.Nub r3 DescriptorProto_ExtensionRangeRow => Record r1 -> DescriptorProto_ExtensionRange
mkDescriptorProto_ExtensionRange r = DescriptorProto_ExtensionRange $ Record.merge r defaultDescriptorProto_ExtensionRange


type DescriptorProto_ReservedRangeRow =
  ( start :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  , __unknown_fields :: Array Runtime.UnknownField
  )
type DescriptorProto_ReservedRangeR = Record DescriptorProto_ReservedRangeRow
newtype DescriptorProto_ReservedRange = DescriptorProto_ReservedRange DescriptorProto_ReservedRangeR
derive instance genericDescriptorProto_ReservedRange :: Generic.Rep.Generic DescriptorProto_ReservedRange _
derive instance newtypeDescriptorProto_ReservedRange :: Newtype.Newtype DescriptorProto_ReservedRange _
derive instance eqDescriptorProto_ReservedRange :: Eq.Eq DescriptorProto_ReservedRange
instance showDescriptorProto_ReservedRange :: Show.Show DescriptorProto_ReservedRange where show x = Generic.Rep.Show.genericShow x

putDescriptorProto_ReservedRange :: forall m. Effect.MonadEffect m => DescriptorProto_ReservedRange -> ArrayBuffer.Builder.PutM m Unit.Unit
putDescriptorProto_ReservedRange (DescriptorProto_ReservedRange r) = do
  Runtime.putOptional 1 r.start Encode.int32
  Runtime.putOptional 2 r.end Encode.int32
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseDescriptorProto_ReservedRange :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m DescriptorProto_ReservedRange
parseDescriptorProto_ReservedRange length = Runtime.label "ReservedRange / " $
  Runtime.parseMessage DescriptorProto_ReservedRange defaultDescriptorProto_ReservedRange parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder DescriptorProto_ReservedRangeR DescriptorProto_ReservedRangeR)
  parseField 1 Common.VarInt = Runtime.label "start / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "start") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultDescriptorProto_ReservedRange :: DescriptorProto_ReservedRangeR
defaultDescriptorProto_ReservedRange =
  { start: Maybe.Nothing
  , end: Maybe.Nothing
  , __unknown_fields: []
  }

mkDescriptorProto_ReservedRange :: forall r1 r3. Prim.Row.Union r1 DescriptorProto_ReservedRangeRow r3 => Prim.Row.Nub r3 DescriptorProto_ReservedRangeRow => Record r1 -> DescriptorProto_ReservedRange
mkDescriptorProto_ReservedRange r = DescriptorProto_ReservedRange $ Record.merge r defaultDescriptorProto_ReservedRange


type ExtensionRangeOptionsRow =
  ( uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type ExtensionRangeOptionsR = Record ExtensionRangeOptionsRow
newtype ExtensionRangeOptions = ExtensionRangeOptions ExtensionRangeOptionsR
derive instance genericExtensionRangeOptions :: Generic.Rep.Generic ExtensionRangeOptions _
derive instance newtypeExtensionRangeOptions :: Newtype.Newtype ExtensionRangeOptions _
derive instance eqExtensionRangeOptions :: Eq.Eq ExtensionRangeOptions
instance showExtensionRangeOptions :: Show.Show ExtensionRangeOptions where show x = Generic.Rep.Show.genericShow x

putExtensionRangeOptions :: forall m. Effect.MonadEffect m => ExtensionRangeOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putExtensionRangeOptions (ExtensionRangeOptions r) = do
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseExtensionRangeOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m ExtensionRangeOptions
parseExtensionRangeOptions length = Runtime.label "ExtensionRangeOptions / " $
  Runtime.parseMessage ExtensionRangeOptions defaultExtensionRangeOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder ExtensionRangeOptionsR ExtensionRangeOptionsR)
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultExtensionRangeOptions :: ExtensionRangeOptionsR
defaultExtensionRangeOptions =
  { uninterpreted_option: []
  , __unknown_fields: []
  }

mkExtensionRangeOptions :: forall r1 r3. Prim.Row.Union r1 ExtensionRangeOptionsRow r3 => Prim.Row.Nub r3 ExtensionRangeOptionsRow => Record r1 -> ExtensionRangeOptions
mkExtensionRangeOptions r = ExtensionRangeOptions $ Record.merge r defaultExtensionRangeOptions


type FieldDescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , number :: Maybe.Maybe Int
  , label :: Maybe.Maybe FieldDescriptorProto_Label
  , type :: Maybe.Maybe FieldDescriptorProto_Type
  , type_name :: Maybe.Maybe String
  , extendee :: Maybe.Maybe String
  , default_value :: Maybe.Maybe String
  , oneof_index :: Maybe.Maybe Int
  , json_name :: Maybe.Maybe String
  , options :: Maybe.Maybe FieldOptions
  , __unknown_fields :: Array Runtime.UnknownField
  )
type FieldDescriptorProtoR = Record FieldDescriptorProtoRow
newtype FieldDescriptorProto = FieldDescriptorProto FieldDescriptorProtoR
derive instance genericFieldDescriptorProto :: Generic.Rep.Generic FieldDescriptorProto _
derive instance newtypeFieldDescriptorProto :: Newtype.Newtype FieldDescriptorProto _
derive instance eqFieldDescriptorProto :: Eq.Eq FieldDescriptorProto
instance showFieldDescriptorProto :: Show.Show FieldDescriptorProto where show x = Generic.Rep.Show.genericShow x

putFieldDescriptorProto :: forall m. Effect.MonadEffect m => FieldDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putFieldDescriptorProto (FieldDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 3 r.number Encode.int32
  Runtime.putOptional 4 r.label Runtime.putEnum
  Runtime.putOptional 5 r.type Runtime.putEnum
  Runtime.putOptional 6 r.type_name Encode.string
  Runtime.putOptional 2 r.extendee Encode.string
  Runtime.putOptional 7 r.default_value Encode.string
  Runtime.putOptional 9 r.oneof_index Encode.int32
  Runtime.putOptional 10 r.json_name Encode.string
  Runtime.putOptional 8 r.options $ Runtime.putLenDel putFieldOptions
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseFieldDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FieldDescriptorProto
parseFieldDescriptorProto length = Runtime.label "FieldDescriptorProto / " $
  Runtime.parseMessage FieldDescriptorProto defaultFieldDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FieldDescriptorProtoR FieldDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "number / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "number") $ Function.const $ Maybe.Just x
  parseField 4 Common.VarInt = Runtime.label "label / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "label") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "type / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "type") $ Function.const $ Maybe.Just x
  parseField 6 Common.LenDel = Runtime.label "type_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "type_name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "extendee / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "extendee") $ Function.const $ Maybe.Just x
  parseField 7 Common.LenDel = Runtime.label "default_value / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "default_value") $ Function.const $ Maybe.Just x
  parseField 9 Common.VarInt = Runtime.label "oneof_index / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "oneof_index") $ Function.const $ Maybe.Just x
  parseField 10 Common.LenDel = Runtime.label "json_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "json_name") $ Function.const $ Maybe.Just x
  parseField 8 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseFieldOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultFieldDescriptorProto :: FieldDescriptorProtoR
defaultFieldDescriptorProto =
  { name: Maybe.Nothing
  , number: Maybe.Nothing
  , label: Maybe.Nothing
  , type: Maybe.Nothing
  , type_name: Maybe.Nothing
  , extendee: Maybe.Nothing
  , default_value: Maybe.Nothing
  , oneof_index: Maybe.Nothing
  , json_name: Maybe.Nothing
  , options: Maybe.Nothing
  , __unknown_fields: []
  }

mkFieldDescriptorProto :: forall r1 r3. Prim.Row.Union r1 FieldDescriptorProtoRow r3 => Prim.Row.Nub r3 FieldDescriptorProtoRow => Record r1 -> FieldDescriptorProto
mkFieldDescriptorProto r = FieldDescriptorProto $ Record.merge r defaultFieldDescriptorProto


type OneofDescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , options :: Maybe.Maybe OneofOptions
  , __unknown_fields :: Array Runtime.UnknownField
  )
type OneofDescriptorProtoR = Record OneofDescriptorProtoRow
newtype OneofDescriptorProto = OneofDescriptorProto OneofDescriptorProtoR
derive instance genericOneofDescriptorProto :: Generic.Rep.Generic OneofDescriptorProto _
derive instance newtypeOneofDescriptorProto :: Newtype.Newtype OneofDescriptorProto _
derive instance eqOneofDescriptorProto :: Eq.Eq OneofDescriptorProto
instance showOneofDescriptorProto :: Show.Show OneofDescriptorProto where show x = Generic.Rep.Show.genericShow x

putOneofDescriptorProto :: forall m. Effect.MonadEffect m => OneofDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putOneofDescriptorProto (OneofDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.options $ Runtime.putLenDel putOneofOptions
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseOneofDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m OneofDescriptorProto
parseOneofDescriptorProto length = Runtime.label "OneofDescriptorProto / " $
  Runtime.parseMessage OneofDescriptorProto defaultOneofDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder OneofDescriptorProtoR OneofDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseOneofOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultOneofDescriptorProto :: OneofDescriptorProtoR
defaultOneofDescriptorProto =
  { name: Maybe.Nothing
  , options: Maybe.Nothing
  , __unknown_fields: []
  }

mkOneofDescriptorProto :: forall r1 r3. Prim.Row.Union r1 OneofDescriptorProtoRow r3 => Prim.Row.Nub r3 OneofDescriptorProtoRow => Record r1 -> OneofDescriptorProto
mkOneofDescriptorProto r = OneofDescriptorProto $ Record.merge r defaultOneofDescriptorProto


type EnumDescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , value :: Array EnumValueDescriptorProto
  , options :: Maybe.Maybe EnumOptions
  , reserved_range :: Array EnumDescriptorProto_EnumReservedRange
  , reserved_name :: Array String
  , __unknown_fields :: Array Runtime.UnknownField
  )
type EnumDescriptorProtoR = Record EnumDescriptorProtoRow
newtype EnumDescriptorProto = EnumDescriptorProto EnumDescriptorProtoR
derive instance genericEnumDescriptorProto :: Generic.Rep.Generic EnumDescriptorProto _
derive instance newtypeEnumDescriptorProto :: Newtype.Newtype EnumDescriptorProto _
derive instance eqEnumDescriptorProto :: Eq.Eq EnumDescriptorProto
instance showEnumDescriptorProto :: Show.Show EnumDescriptorProto where show x = Generic.Rep.Show.genericShow x

putEnumDescriptorProto :: forall m. Effect.MonadEffect m => EnumDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumDescriptorProto (EnumDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putRepeated 2 r.value $ Runtime.putLenDel putEnumValueDescriptorProto
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putEnumOptions
  Runtime.putRepeated 4 r.reserved_range $ Runtime.putLenDel putEnumDescriptorProto_EnumReservedRange
  Runtime.putRepeated 5 r.reserved_name Encode.string
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseEnumDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumDescriptorProto
parseEnumDescriptorProto length = Runtime.label "EnumDescriptorProto / " $
  Runtime.parseMessage EnumDescriptorProto defaultEnumDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumDescriptorProtoR EnumDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "value / " $ do
    x <- Runtime.parseLenDel parseEnumValueDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "value") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseEnumOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 4 Common.LenDel = Runtime.label "reserved_range / " $ do
    x <- Runtime.parseLenDel parseEnumDescriptorProto_EnumReservedRange
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_range") $ Function.flip Array.snoc x
  parseField 5 Common.LenDel = Runtime.label "reserved_name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "reserved_name") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultEnumDescriptorProto :: EnumDescriptorProtoR
defaultEnumDescriptorProto =
  { name: Maybe.Nothing
  , value: []
  , options: Maybe.Nothing
  , reserved_range: []
  , reserved_name: []
  , __unknown_fields: []
  }

mkEnumDescriptorProto :: forall r1 r3. Prim.Row.Union r1 EnumDescriptorProtoRow r3 => Prim.Row.Nub r3 EnumDescriptorProtoRow => Record r1 -> EnumDescriptorProto
mkEnumDescriptorProto r = EnumDescriptorProto $ Record.merge r defaultEnumDescriptorProto


type EnumDescriptorProto_EnumReservedRangeRow =
  ( start :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  , __unknown_fields :: Array Runtime.UnknownField
  )
type EnumDescriptorProto_EnumReservedRangeR = Record EnumDescriptorProto_EnumReservedRangeRow
newtype EnumDescriptorProto_EnumReservedRange = EnumDescriptorProto_EnumReservedRange EnumDescriptorProto_EnumReservedRangeR
derive instance genericEnumDescriptorProto_EnumReservedRange :: Generic.Rep.Generic EnumDescriptorProto_EnumReservedRange _
derive instance newtypeEnumDescriptorProto_EnumReservedRange :: Newtype.Newtype EnumDescriptorProto_EnumReservedRange _
derive instance eqEnumDescriptorProto_EnumReservedRange :: Eq.Eq EnumDescriptorProto_EnumReservedRange
instance showEnumDescriptorProto_EnumReservedRange :: Show.Show EnumDescriptorProto_EnumReservedRange where show x = Generic.Rep.Show.genericShow x

putEnumDescriptorProto_EnumReservedRange :: forall m. Effect.MonadEffect m => EnumDescriptorProto_EnumReservedRange -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumDescriptorProto_EnumReservedRange (EnumDescriptorProto_EnumReservedRange r) = do
  Runtime.putOptional 1 r.start Encode.int32
  Runtime.putOptional 2 r.end Encode.int32
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseEnumDescriptorProto_EnumReservedRange :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumDescriptorProto_EnumReservedRange
parseEnumDescriptorProto_EnumReservedRange length = Runtime.label "EnumReservedRange / " $
  Runtime.parseMessage EnumDescriptorProto_EnumReservedRange defaultEnumDescriptorProto_EnumReservedRange parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumDescriptorProto_EnumReservedRangeR EnumDescriptorProto_EnumReservedRangeR)
  parseField 1 Common.VarInt = Runtime.label "start / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "start") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultEnumDescriptorProto_EnumReservedRange :: EnumDescriptorProto_EnumReservedRangeR
defaultEnumDescriptorProto_EnumReservedRange =
  { start: Maybe.Nothing
  , end: Maybe.Nothing
  , __unknown_fields: []
  }

mkEnumDescriptorProto_EnumReservedRange :: forall r1 r3. Prim.Row.Union r1 EnumDescriptorProto_EnumReservedRangeRow r3 => Prim.Row.Nub r3 EnumDescriptorProto_EnumReservedRangeRow => Record r1 -> EnumDescriptorProto_EnumReservedRange
mkEnumDescriptorProto_EnumReservedRange r = EnumDescriptorProto_EnumReservedRange $ Record.merge r defaultEnumDescriptorProto_EnumReservedRange


type EnumValueDescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , number :: Maybe.Maybe Int
  , options :: Maybe.Maybe EnumValueOptions
  , __unknown_fields :: Array Runtime.UnknownField
  )
type EnumValueDescriptorProtoR = Record EnumValueDescriptorProtoRow
newtype EnumValueDescriptorProto = EnumValueDescriptorProto EnumValueDescriptorProtoR
derive instance genericEnumValueDescriptorProto :: Generic.Rep.Generic EnumValueDescriptorProto _
derive instance newtypeEnumValueDescriptorProto :: Newtype.Newtype EnumValueDescriptorProto _
derive instance eqEnumValueDescriptorProto :: Eq.Eq EnumValueDescriptorProto
instance showEnumValueDescriptorProto :: Show.Show EnumValueDescriptorProto where show x = Generic.Rep.Show.genericShow x

putEnumValueDescriptorProto :: forall m. Effect.MonadEffect m => EnumValueDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumValueDescriptorProto (EnumValueDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.number Encode.int32
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putEnumValueOptions
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseEnumValueDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumValueDescriptorProto
parseEnumValueDescriptorProto length = Runtime.label "EnumValueDescriptorProto / " $
  Runtime.parseMessage EnumValueDescriptorProto defaultEnumValueDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumValueDescriptorProtoR EnumValueDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "number / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "number") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseEnumValueOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultEnumValueDescriptorProto :: EnumValueDescriptorProtoR
defaultEnumValueDescriptorProto =
  { name: Maybe.Nothing
  , number: Maybe.Nothing
  , options: Maybe.Nothing
  , __unknown_fields: []
  }

mkEnumValueDescriptorProto :: forall r1 r3. Prim.Row.Union r1 EnumValueDescriptorProtoRow r3 => Prim.Row.Nub r3 EnumValueDescriptorProtoRow => Record r1 -> EnumValueDescriptorProto
mkEnumValueDescriptorProto r = EnumValueDescriptorProto $ Record.merge r defaultEnumValueDescriptorProto


type ServiceDescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , method :: Array MethodDescriptorProto
  , options :: Maybe.Maybe ServiceOptions
  , __unknown_fields :: Array Runtime.UnknownField
  )
type ServiceDescriptorProtoR = Record ServiceDescriptorProtoRow
newtype ServiceDescriptorProto = ServiceDescriptorProto ServiceDescriptorProtoR
derive instance genericServiceDescriptorProto :: Generic.Rep.Generic ServiceDescriptorProto _
derive instance newtypeServiceDescriptorProto :: Newtype.Newtype ServiceDescriptorProto _
derive instance eqServiceDescriptorProto :: Eq.Eq ServiceDescriptorProto
instance showServiceDescriptorProto :: Show.Show ServiceDescriptorProto where show x = Generic.Rep.Show.genericShow x

putServiceDescriptorProto :: forall m. Effect.MonadEffect m => ServiceDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putServiceDescriptorProto (ServiceDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putRepeated 2 r.method $ Runtime.putLenDel putMethodDescriptorProto
  Runtime.putOptional 3 r.options $ Runtime.putLenDel putServiceOptions
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseServiceDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m ServiceDescriptorProto
parseServiceDescriptorProto length = Runtime.label "ServiceDescriptorProto / " $
  Runtime.parseMessage ServiceDescriptorProto defaultServiceDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder ServiceDescriptorProtoR ServiceDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "method / " $ do
    x <- Runtime.parseLenDel parseMethodDescriptorProto
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "method") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseServiceOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultServiceDescriptorProto :: ServiceDescriptorProtoR
defaultServiceDescriptorProto =
  { name: Maybe.Nothing
  , method: []
  , options: Maybe.Nothing
  , __unknown_fields: []
  }

mkServiceDescriptorProto :: forall r1 r3. Prim.Row.Union r1 ServiceDescriptorProtoRow r3 => Prim.Row.Nub r3 ServiceDescriptorProtoRow => Record r1 -> ServiceDescriptorProto
mkServiceDescriptorProto r = ServiceDescriptorProto $ Record.merge r defaultServiceDescriptorProto


type MethodDescriptorProtoRow =
  ( name :: Maybe.Maybe String
  , input_type :: Maybe.Maybe String
  , output_type :: Maybe.Maybe String
  , options :: Maybe.Maybe MethodOptions
  , client_streaming :: Maybe.Maybe Boolean
  , server_streaming :: Maybe.Maybe Boolean
  , __unknown_fields :: Array Runtime.UnknownField
  )
type MethodDescriptorProtoR = Record MethodDescriptorProtoRow
newtype MethodDescriptorProto = MethodDescriptorProto MethodDescriptorProtoR
derive instance genericMethodDescriptorProto :: Generic.Rep.Generic MethodDescriptorProto _
derive instance newtypeMethodDescriptorProto :: Newtype.Newtype MethodDescriptorProto _
derive instance eqMethodDescriptorProto :: Eq.Eq MethodDescriptorProto
instance showMethodDescriptorProto :: Show.Show MethodDescriptorProto where show x = Generic.Rep.Show.genericShow x

putMethodDescriptorProto :: forall m. Effect.MonadEffect m => MethodDescriptorProto -> ArrayBuffer.Builder.PutM m Unit.Unit
putMethodDescriptorProto (MethodDescriptorProto r) = do
  Runtime.putOptional 1 r.name Encode.string
  Runtime.putOptional 2 r.input_type Encode.string
  Runtime.putOptional 3 r.output_type Encode.string
  Runtime.putOptional 4 r.options $ Runtime.putLenDel putMethodOptions
  Runtime.putOptional 5 r.client_streaming Encode.bool
  Runtime.putOptional 6 r.server_streaming Encode.bool
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseMethodDescriptorProto :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m MethodDescriptorProto
parseMethodDescriptorProto length = Runtime.label "MethodDescriptorProto / " $
  Runtime.parseMessage MethodDescriptorProto defaultMethodDescriptorProto parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder MethodDescriptorProtoR MethodDescriptorProtoR)
  parseField 1 Common.LenDel = Runtime.label "name / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.const $ Maybe.Just x
  parseField 2 Common.LenDel = Runtime.label "input_type / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "input_type") $ Function.const $ Maybe.Just x
  parseField 3 Common.LenDel = Runtime.label "output_type / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "output_type") $ Function.const $ Maybe.Just x
  parseField 4 Common.LenDel = Runtime.label "options / " $ do
    x <- Runtime.parseLenDel parseMethodOptions
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "options") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "client_streaming / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "client_streaming") $ Function.const $ Maybe.Just x
  parseField 6 Common.VarInt = Runtime.label "server_streaming / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "server_streaming") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultMethodDescriptorProto :: MethodDescriptorProtoR
defaultMethodDescriptorProto =
  { name: Maybe.Nothing
  , input_type: Maybe.Nothing
  , output_type: Maybe.Nothing
  , options: Maybe.Nothing
  , client_streaming: Maybe.Nothing
  , server_streaming: Maybe.Nothing
  , __unknown_fields: []
  }

mkMethodDescriptorProto :: forall r1 r3. Prim.Row.Union r1 MethodDescriptorProtoRow r3 => Prim.Row.Nub r3 MethodDescriptorProtoRow => Record r1 -> MethodDescriptorProto
mkMethodDescriptorProto r = MethodDescriptorProto $ Record.merge r defaultMethodDescriptorProto


type FileOptionsRow =
  ( java_package :: Maybe.Maybe String
  , java_outer_classname :: Maybe.Maybe String
  , java_multiple_files :: Maybe.Maybe Boolean
  , java_generate_equals_and_hash :: Maybe.Maybe Boolean
  , java_string_check_utf8 :: Maybe.Maybe Boolean
  , optimize_for :: Maybe.Maybe FileOptions_OptimizeMode
  , go_package :: Maybe.Maybe String
  , cc_generic_services :: Maybe.Maybe Boolean
  , java_generic_services :: Maybe.Maybe Boolean
  , py_generic_services :: Maybe.Maybe Boolean
  , php_generic_services :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , cc_enable_arenas :: Maybe.Maybe Boolean
  , objc_class_prefix :: Maybe.Maybe String
  , csharp_namespace :: Maybe.Maybe String
  , swift_prefix :: Maybe.Maybe String
  , php_class_prefix :: Maybe.Maybe String
  , php_namespace :: Maybe.Maybe String
  , php_metadata_namespace :: Maybe.Maybe String
  , ruby_package :: Maybe.Maybe String
  , uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type FileOptionsR = Record FileOptionsRow
newtype FileOptions = FileOptions FileOptionsR
derive instance genericFileOptions :: Generic.Rep.Generic FileOptions _
derive instance newtypeFileOptions :: Newtype.Newtype FileOptions _
derive instance eqFileOptions :: Eq.Eq FileOptions
instance showFileOptions :: Show.Show FileOptions where show x = Generic.Rep.Show.genericShow x

putFileOptions :: forall m. Effect.MonadEffect m => FileOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putFileOptions (FileOptions r) = do
  Runtime.putOptional 1 r.java_package Encode.string
  Runtime.putOptional 8 r.java_outer_classname Encode.string
  Runtime.putOptional 10 r.java_multiple_files Encode.bool
  Runtime.putOptional 20 r.java_generate_equals_and_hash Encode.bool
  Runtime.putOptional 27 r.java_string_check_utf8 Encode.bool
  Runtime.putOptional 9 r.optimize_for Runtime.putEnum
  Runtime.putOptional 11 r.go_package Encode.string
  Runtime.putOptional 16 r.cc_generic_services Encode.bool
  Runtime.putOptional 17 r.java_generic_services Encode.bool
  Runtime.putOptional 18 r.py_generic_services Encode.bool
  Runtime.putOptional 42 r.php_generic_services Encode.bool
  Runtime.putOptional 23 r.deprecated Encode.bool
  Runtime.putOptional 31 r.cc_enable_arenas Encode.bool
  Runtime.putOptional 36 r.objc_class_prefix Encode.string
  Runtime.putOptional 37 r.csharp_namespace Encode.string
  Runtime.putOptional 39 r.swift_prefix Encode.string
  Runtime.putOptional 40 r.php_class_prefix Encode.string
  Runtime.putOptional 41 r.php_namespace Encode.string
  Runtime.putOptional 44 r.php_metadata_namespace Encode.string
  Runtime.putOptional 45 r.ruby_package Encode.string
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseFileOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FileOptions
parseFileOptions length = Runtime.label "FileOptions / " $
  Runtime.parseMessage FileOptions defaultFileOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FileOptionsR FileOptionsR)
  parseField 1 Common.LenDel = Runtime.label "java_package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_package") $ Function.const $ Maybe.Just x
  parseField 8 Common.LenDel = Runtime.label "java_outer_classname / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_outer_classname") $ Function.const $ Maybe.Just x
  parseField 10 Common.VarInt = Runtime.label "java_multiple_files / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_multiple_files") $ Function.const $ Maybe.Just x
  parseField 20 Common.VarInt = Runtime.label "java_generate_equals_and_hash / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_generate_equals_and_hash") $ Function.const $ Maybe.Just x
  parseField 27 Common.VarInt = Runtime.label "java_string_check_utf8 / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_string_check_utf8") $ Function.const $ Maybe.Just x
  parseField 9 Common.VarInt = Runtime.label "optimize_for / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "optimize_for") $ Function.const $ Maybe.Just x
  parseField 11 Common.LenDel = Runtime.label "go_package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "go_package") $ Function.const $ Maybe.Just x
  parseField 16 Common.VarInt = Runtime.label "cc_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "cc_generic_services") $ Function.const $ Maybe.Just x
  parseField 17 Common.VarInt = Runtime.label "java_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "java_generic_services") $ Function.const $ Maybe.Just x
  parseField 18 Common.VarInt = Runtime.label "py_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "py_generic_services") $ Function.const $ Maybe.Just x
  parseField 42 Common.VarInt = Runtime.label "php_generic_services / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_generic_services") $ Function.const $ Maybe.Just x
  parseField 23 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 31 Common.VarInt = Runtime.label "cc_enable_arenas / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "cc_enable_arenas") $ Function.const $ Maybe.Just x
  parseField 36 Common.LenDel = Runtime.label "objc_class_prefix / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "objc_class_prefix") $ Function.const $ Maybe.Just x
  parseField 37 Common.LenDel = Runtime.label "csharp_namespace / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "csharp_namespace") $ Function.const $ Maybe.Just x
  parseField 39 Common.LenDel = Runtime.label "swift_prefix / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "swift_prefix") $ Function.const $ Maybe.Just x
  parseField 40 Common.LenDel = Runtime.label "php_class_prefix / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_class_prefix") $ Function.const $ Maybe.Just x
  parseField 41 Common.LenDel = Runtime.label "php_namespace / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_namespace") $ Function.const $ Maybe.Just x
  parseField 44 Common.LenDel = Runtime.label "php_metadata_namespace / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "php_metadata_namespace") $ Function.const $ Maybe.Just x
  parseField 45 Common.LenDel = Runtime.label "ruby_package / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "ruby_package") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultFileOptions :: FileOptionsR
defaultFileOptions =
  { java_package: Maybe.Nothing
  , java_outer_classname: Maybe.Nothing
  , java_multiple_files: Maybe.Nothing
  , java_generate_equals_and_hash: Maybe.Nothing
  , java_string_check_utf8: Maybe.Nothing
  , optimize_for: Maybe.Nothing
  , go_package: Maybe.Nothing
  , cc_generic_services: Maybe.Nothing
  , java_generic_services: Maybe.Nothing
  , py_generic_services: Maybe.Nothing
  , php_generic_services: Maybe.Nothing
  , deprecated: Maybe.Nothing
  , cc_enable_arenas: Maybe.Nothing
  , objc_class_prefix: Maybe.Nothing
  , csharp_namespace: Maybe.Nothing
  , swift_prefix: Maybe.Nothing
  , php_class_prefix: Maybe.Nothing
  , php_namespace: Maybe.Nothing
  , php_metadata_namespace: Maybe.Nothing
  , ruby_package: Maybe.Nothing
  , uninterpreted_option: []
  , __unknown_fields: []
  }

mkFileOptions :: forall r1 r3. Prim.Row.Union r1 FileOptionsRow r3 => Prim.Row.Nub r3 FileOptionsRow => Record r1 -> FileOptions
mkFileOptions r = FileOptions $ Record.merge r defaultFileOptions


type MessageOptionsRow =
  ( message_set_wire_format :: Maybe.Maybe Boolean
  , no_standard_descriptor_accessor :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , map_entry :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type MessageOptionsR = Record MessageOptionsRow
newtype MessageOptions = MessageOptions MessageOptionsR
derive instance genericMessageOptions :: Generic.Rep.Generic MessageOptions _
derive instance newtypeMessageOptions :: Newtype.Newtype MessageOptions _
derive instance eqMessageOptions :: Eq.Eq MessageOptions
instance showMessageOptions :: Show.Show MessageOptions where show x = Generic.Rep.Show.genericShow x

putMessageOptions :: forall m. Effect.MonadEffect m => MessageOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putMessageOptions (MessageOptions r) = do
  Runtime.putOptional 1 r.message_set_wire_format Encode.bool
  Runtime.putOptional 2 r.no_standard_descriptor_accessor Encode.bool
  Runtime.putOptional 3 r.deprecated Encode.bool
  Runtime.putOptional 7 r.map_entry Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseMessageOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m MessageOptions
parseMessageOptions length = Runtime.label "MessageOptions / " $
  Runtime.parseMessage MessageOptions defaultMessageOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder MessageOptionsR MessageOptionsR)
  parseField 1 Common.VarInt = Runtime.label "message_set_wire_format / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "message_set_wire_format") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "no_standard_descriptor_accessor / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "no_standard_descriptor_accessor") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 7 Common.VarInt = Runtime.label "map_entry / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "map_entry") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultMessageOptions :: MessageOptionsR
defaultMessageOptions =
  { message_set_wire_format: Maybe.Nothing
  , no_standard_descriptor_accessor: Maybe.Nothing
  , deprecated: Maybe.Nothing
  , map_entry: Maybe.Nothing
  , uninterpreted_option: []
  , __unknown_fields: []
  }

mkMessageOptions :: forall r1 r3. Prim.Row.Union r1 MessageOptionsRow r3 => Prim.Row.Nub r3 MessageOptionsRow => Record r1 -> MessageOptions
mkMessageOptions r = MessageOptions $ Record.merge r defaultMessageOptions


type FieldOptionsRow =
  ( ctype :: Maybe.Maybe FieldOptions_CType
  , packed :: Maybe.Maybe Boolean
  , jstype :: Maybe.Maybe FieldOptions_JSType
  , lazy :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , weak :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type FieldOptionsR = Record FieldOptionsRow
newtype FieldOptions = FieldOptions FieldOptionsR
derive instance genericFieldOptions :: Generic.Rep.Generic FieldOptions _
derive instance newtypeFieldOptions :: Newtype.Newtype FieldOptions _
derive instance eqFieldOptions :: Eq.Eq FieldOptions
instance showFieldOptions :: Show.Show FieldOptions where show x = Generic.Rep.Show.genericShow x

putFieldOptions :: forall m. Effect.MonadEffect m => FieldOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putFieldOptions (FieldOptions r) = do
  Runtime.putOptional 1 r.ctype Runtime.putEnum
  Runtime.putOptional 2 r.packed Encode.bool
  Runtime.putOptional 6 r.jstype Runtime.putEnum
  Runtime.putOptional 5 r.lazy Encode.bool
  Runtime.putOptional 3 r.deprecated Encode.bool
  Runtime.putOptional 10 r.weak Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseFieldOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m FieldOptions
parseFieldOptions length = Runtime.label "FieldOptions / " $
  Runtime.parseMessage FieldOptions defaultFieldOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder FieldOptionsR FieldOptionsR)
  parseField 1 Common.VarInt = Runtime.label "ctype / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "ctype") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "packed / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "packed") $ Function.const $ Maybe.Just x
  parseField 6 Common.VarInt = Runtime.label "jstype / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "jstype") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "lazy / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "lazy") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 10 Common.VarInt = Runtime.label "weak / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "weak") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultFieldOptions :: FieldOptionsR
defaultFieldOptions =
  { ctype: Maybe.Nothing
  , packed: Maybe.Nothing
  , jstype: Maybe.Nothing
  , lazy: Maybe.Nothing
  , deprecated: Maybe.Nothing
  , weak: Maybe.Nothing
  , uninterpreted_option: []
  , __unknown_fields: []
  }

mkFieldOptions :: forall r1 r3. Prim.Row.Union r1 FieldOptionsRow r3 => Prim.Row.Nub r3 FieldOptionsRow => Record r1 -> FieldOptions
mkFieldOptions r = FieldOptions $ Record.merge r defaultFieldOptions


type OneofOptionsRow =
  ( uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type OneofOptionsR = Record OneofOptionsRow
newtype OneofOptions = OneofOptions OneofOptionsR
derive instance genericOneofOptions :: Generic.Rep.Generic OneofOptions _
derive instance newtypeOneofOptions :: Newtype.Newtype OneofOptions _
derive instance eqOneofOptions :: Eq.Eq OneofOptions
instance showOneofOptions :: Show.Show OneofOptions where show x = Generic.Rep.Show.genericShow x

putOneofOptions :: forall m. Effect.MonadEffect m => OneofOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putOneofOptions (OneofOptions r) = do
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseOneofOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m OneofOptions
parseOneofOptions length = Runtime.label "OneofOptions / " $
  Runtime.parseMessage OneofOptions defaultOneofOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder OneofOptionsR OneofOptionsR)
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultOneofOptions :: OneofOptionsR
defaultOneofOptions =
  { uninterpreted_option: []
  , __unknown_fields: []
  }

mkOneofOptions :: forall r1 r3. Prim.Row.Union r1 OneofOptionsRow r3 => Prim.Row.Nub r3 OneofOptionsRow => Record r1 -> OneofOptions
mkOneofOptions r = OneofOptions $ Record.merge r defaultOneofOptions


type EnumOptionsRow =
  ( allow_alias :: Maybe.Maybe Boolean
  , deprecated :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type EnumOptionsR = Record EnumOptionsRow
newtype EnumOptions = EnumOptions EnumOptionsR
derive instance genericEnumOptions :: Generic.Rep.Generic EnumOptions _
derive instance newtypeEnumOptions :: Newtype.Newtype EnumOptions _
derive instance eqEnumOptions :: Eq.Eq EnumOptions
instance showEnumOptions :: Show.Show EnumOptions where show x = Generic.Rep.Show.genericShow x

putEnumOptions :: forall m. Effect.MonadEffect m => EnumOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumOptions (EnumOptions r) = do
  Runtime.putOptional 2 r.allow_alias Encode.bool
  Runtime.putOptional 3 r.deprecated Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseEnumOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumOptions
parseEnumOptions length = Runtime.label "EnumOptions / " $
  Runtime.parseMessage EnumOptions defaultEnumOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumOptionsR EnumOptionsR)
  parseField 2 Common.VarInt = Runtime.label "allow_alias / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "allow_alias") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultEnumOptions :: EnumOptionsR
defaultEnumOptions =
  { allow_alias: Maybe.Nothing
  , deprecated: Maybe.Nothing
  , uninterpreted_option: []
  , __unknown_fields: []
  }

mkEnumOptions :: forall r1 r3. Prim.Row.Union r1 EnumOptionsRow r3 => Prim.Row.Nub r3 EnumOptionsRow => Record r1 -> EnumOptions
mkEnumOptions r = EnumOptions $ Record.merge r defaultEnumOptions


type EnumValueOptionsRow =
  ( deprecated :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type EnumValueOptionsR = Record EnumValueOptionsRow
newtype EnumValueOptions = EnumValueOptions EnumValueOptionsR
derive instance genericEnumValueOptions :: Generic.Rep.Generic EnumValueOptions _
derive instance newtypeEnumValueOptions :: Newtype.Newtype EnumValueOptions _
derive instance eqEnumValueOptions :: Eq.Eq EnumValueOptions
instance showEnumValueOptions :: Show.Show EnumValueOptions where show x = Generic.Rep.Show.genericShow x

putEnumValueOptions :: forall m. Effect.MonadEffect m => EnumValueOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putEnumValueOptions (EnumValueOptions r) = do
  Runtime.putOptional 1 r.deprecated Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseEnumValueOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m EnumValueOptions
parseEnumValueOptions length = Runtime.label "EnumValueOptions / " $
  Runtime.parseMessage EnumValueOptions defaultEnumValueOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder EnumValueOptionsR EnumValueOptionsR)
  parseField 1 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultEnumValueOptions :: EnumValueOptionsR
defaultEnumValueOptions =
  { deprecated: Maybe.Nothing
  , uninterpreted_option: []
  , __unknown_fields: []
  }

mkEnumValueOptions :: forall r1 r3. Prim.Row.Union r1 EnumValueOptionsRow r3 => Prim.Row.Nub r3 EnumValueOptionsRow => Record r1 -> EnumValueOptions
mkEnumValueOptions r = EnumValueOptions $ Record.merge r defaultEnumValueOptions


type ServiceOptionsRow =
  ( deprecated :: Maybe.Maybe Boolean
  , uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type ServiceOptionsR = Record ServiceOptionsRow
newtype ServiceOptions = ServiceOptions ServiceOptionsR
derive instance genericServiceOptions :: Generic.Rep.Generic ServiceOptions _
derive instance newtypeServiceOptions :: Newtype.Newtype ServiceOptions _
derive instance eqServiceOptions :: Eq.Eq ServiceOptions
instance showServiceOptions :: Show.Show ServiceOptions where show x = Generic.Rep.Show.genericShow x

putServiceOptions :: forall m. Effect.MonadEffect m => ServiceOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putServiceOptions (ServiceOptions r) = do
  Runtime.putOptional 33 r.deprecated Encode.bool
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseServiceOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m ServiceOptions
parseServiceOptions length = Runtime.label "ServiceOptions / " $
  Runtime.parseMessage ServiceOptions defaultServiceOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder ServiceOptionsR ServiceOptionsR)
  parseField 33 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultServiceOptions :: ServiceOptionsR
defaultServiceOptions =
  { deprecated: Maybe.Nothing
  , uninterpreted_option: []
  , __unknown_fields: []
  }

mkServiceOptions :: forall r1 r3. Prim.Row.Union r1 ServiceOptionsRow r3 => Prim.Row.Nub r3 ServiceOptionsRow => Record r1 -> ServiceOptions
mkServiceOptions r = ServiceOptions $ Record.merge r defaultServiceOptions


type MethodOptionsRow =
  ( deprecated :: Maybe.Maybe Boolean
  , idempotency_level :: Maybe.Maybe MethodOptions_IdempotencyLevel
  , uninterpreted_option :: Array UninterpretedOption
  , __unknown_fields :: Array Runtime.UnknownField
  )
type MethodOptionsR = Record MethodOptionsRow
newtype MethodOptions = MethodOptions MethodOptionsR
derive instance genericMethodOptions :: Generic.Rep.Generic MethodOptions _
derive instance newtypeMethodOptions :: Newtype.Newtype MethodOptions _
derive instance eqMethodOptions :: Eq.Eq MethodOptions
instance showMethodOptions :: Show.Show MethodOptions where show x = Generic.Rep.Show.genericShow x

putMethodOptions :: forall m. Effect.MonadEffect m => MethodOptions -> ArrayBuffer.Builder.PutM m Unit.Unit
putMethodOptions (MethodOptions r) = do
  Runtime.putOptional 33 r.deprecated Encode.bool
  Runtime.putOptional 34 r.idempotency_level Runtime.putEnum
  Runtime.putRepeated 999 r.uninterpreted_option $ Runtime.putLenDel putUninterpretedOption
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseMethodOptions :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m MethodOptions
parseMethodOptions length = Runtime.label "MethodOptions / " $
  Runtime.parseMessage MethodOptions defaultMethodOptions parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder MethodOptionsR MethodOptionsR)
  parseField 33 Common.VarInt = Runtime.label "deprecated / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "deprecated") $ Function.const $ Maybe.Just x
  parseField 34 Common.VarInt = Runtime.label "idempotency_level / " $ do
    x <- Runtime.parseEnum
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "idempotency_level") $ Function.const $ Maybe.Just x
  parseField 999 Common.LenDel = Runtime.label "uninterpreted_option / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "uninterpreted_option") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultMethodOptions :: MethodOptionsR
defaultMethodOptions =
  { deprecated: Maybe.Nothing
  , idempotency_level: Maybe.Nothing
  , uninterpreted_option: []
  , __unknown_fields: []
  }

mkMethodOptions :: forall r1 r3. Prim.Row.Union r1 MethodOptionsRow r3 => Prim.Row.Nub r3 MethodOptionsRow => Record r1 -> MethodOptions
mkMethodOptions r = MethodOptions $ Record.merge r defaultMethodOptions


type UninterpretedOptionRow =
  ( name :: Array UninterpretedOption_NamePart
  , identifier_value :: Maybe.Maybe String
  , positive_int_value :: Maybe.Maybe (Long.Long Long.Unsigned)
  , negative_int_value :: Maybe.Maybe (Long.Long Long.Signed)
  , double_value :: Maybe.Maybe Number
  , string_value :: Maybe.Maybe Common.Bytes
  , aggregate_value :: Maybe.Maybe String
  , __unknown_fields :: Array Runtime.UnknownField
  )
type UninterpretedOptionR = Record UninterpretedOptionRow
newtype UninterpretedOption = UninterpretedOption UninterpretedOptionR
derive instance genericUninterpretedOption :: Generic.Rep.Generic UninterpretedOption _
derive instance newtypeUninterpretedOption :: Newtype.Newtype UninterpretedOption _
derive instance eqUninterpretedOption :: Eq.Eq UninterpretedOption
instance showUninterpretedOption :: Show.Show UninterpretedOption where show x = Generic.Rep.Show.genericShow x

putUninterpretedOption :: forall m. Effect.MonadEffect m => UninterpretedOption -> ArrayBuffer.Builder.PutM m Unit.Unit
putUninterpretedOption (UninterpretedOption r) = do
  Runtime.putRepeated 2 r.name $ Runtime.putLenDel putUninterpretedOption_NamePart
  Runtime.putOptional 3 r.identifier_value Encode.string
  Runtime.putOptional 4 r.positive_int_value Encode.uint64
  Runtime.putOptional 5 r.negative_int_value Encode.int64
  Runtime.putOptional 6 r.double_value Encode.double
  Runtime.putOptional 7 r.string_value Encode.bytes
  Runtime.putOptional 8 r.aggregate_value Encode.string
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseUninterpretedOption :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m UninterpretedOption
parseUninterpretedOption length = Runtime.label "UninterpretedOption / " $
  Runtime.parseMessage UninterpretedOption defaultUninterpretedOption parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder UninterpretedOptionR UninterpretedOptionR)
  parseField 2 Common.LenDel = Runtime.label "name / " $ do
    x <- Runtime.parseLenDel parseUninterpretedOption_NamePart
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name") $ Function.flip Array.snoc x
  parseField 3 Common.LenDel = Runtime.label "identifier_value / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "identifier_value") $ Function.const $ Maybe.Just x
  parseField 4 Common.VarInt = Runtime.label "positive_int_value / " $ do
    x <- Decode.uint64
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "positive_int_value") $ Function.const $ Maybe.Just x
  parseField 5 Common.VarInt = Runtime.label "negative_int_value / " $ do
    x <- Decode.int64
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "negative_int_value") $ Function.const $ Maybe.Just x
  parseField 6 Common.Bits64 = Runtime.label "double_value / " $ do
    x <- Decode.double
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "double_value") $ Function.const $ Maybe.Just x
  parseField 7 Common.LenDel = Runtime.label "string_value / " $ do
    x <- Decode.bytes
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "string_value") $ Function.const $ Maybe.Just x
  parseField 8 Common.LenDel = Runtime.label "aggregate_value / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "aggregate_value") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultUninterpretedOption :: UninterpretedOptionR
defaultUninterpretedOption =
  { name: []
  , identifier_value: Maybe.Nothing
  , positive_int_value: Maybe.Nothing
  , negative_int_value: Maybe.Nothing
  , double_value: Maybe.Nothing
  , string_value: Maybe.Nothing
  , aggregate_value: Maybe.Nothing
  , __unknown_fields: []
  }

mkUninterpretedOption :: forall r1 r3. Prim.Row.Union r1 UninterpretedOptionRow r3 => Prim.Row.Nub r3 UninterpretedOptionRow => Record r1 -> UninterpretedOption
mkUninterpretedOption r = UninterpretedOption $ Record.merge r defaultUninterpretedOption


type UninterpretedOption_NamePartRow =
  ( name_part :: Maybe.Maybe String
  , is_extension :: Maybe.Maybe Boolean
  , __unknown_fields :: Array Runtime.UnknownField
  )
type UninterpretedOption_NamePartR = Record UninterpretedOption_NamePartRow
newtype UninterpretedOption_NamePart = UninterpretedOption_NamePart UninterpretedOption_NamePartR
derive instance genericUninterpretedOption_NamePart :: Generic.Rep.Generic UninterpretedOption_NamePart _
derive instance newtypeUninterpretedOption_NamePart :: Newtype.Newtype UninterpretedOption_NamePart _
derive instance eqUninterpretedOption_NamePart :: Eq.Eq UninterpretedOption_NamePart
instance showUninterpretedOption_NamePart :: Show.Show UninterpretedOption_NamePart where show x = Generic.Rep.Show.genericShow x

putUninterpretedOption_NamePart :: forall m. Effect.MonadEffect m => UninterpretedOption_NamePart -> ArrayBuffer.Builder.PutM m Unit.Unit
putUninterpretedOption_NamePart (UninterpretedOption_NamePart r) = do
  Runtime.putOptional 1 r.name_part Encode.string
  Runtime.putOptional 2 r.is_extension Encode.bool
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseUninterpretedOption_NamePart :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m UninterpretedOption_NamePart
parseUninterpretedOption_NamePart length = Runtime.label "NamePart / " $
  Runtime.parseMessage UninterpretedOption_NamePart defaultUninterpretedOption_NamePart parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder UninterpretedOption_NamePartR UninterpretedOption_NamePartR)
  parseField 1 Common.LenDel = Runtime.label "name_part / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "name_part") $ Function.const $ Maybe.Just x
  parseField 2 Common.VarInt = Runtime.label "is_extension / " $ do
    x <- Decode.bool
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "is_extension") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultUninterpretedOption_NamePart :: UninterpretedOption_NamePartR
defaultUninterpretedOption_NamePart =
  { name_part: Maybe.Nothing
  , is_extension: Maybe.Nothing
  , __unknown_fields: []
  }

mkUninterpretedOption_NamePart :: forall r1 r3. Prim.Row.Union r1 UninterpretedOption_NamePartRow r3 => Prim.Row.Nub r3 UninterpretedOption_NamePartRow => Record r1 -> UninterpretedOption_NamePart
mkUninterpretedOption_NamePart r = UninterpretedOption_NamePart $ Record.merge r defaultUninterpretedOption_NamePart


type SourceCodeInfoRow =
  ( location :: Array SourceCodeInfo_Location
  , __unknown_fields :: Array Runtime.UnknownField
  )
type SourceCodeInfoR = Record SourceCodeInfoRow
newtype SourceCodeInfo = SourceCodeInfo SourceCodeInfoR
derive instance genericSourceCodeInfo :: Generic.Rep.Generic SourceCodeInfo _
derive instance newtypeSourceCodeInfo :: Newtype.Newtype SourceCodeInfo _
derive instance eqSourceCodeInfo :: Eq.Eq SourceCodeInfo
instance showSourceCodeInfo :: Show.Show SourceCodeInfo where show x = Generic.Rep.Show.genericShow x

putSourceCodeInfo :: forall m. Effect.MonadEffect m => SourceCodeInfo -> ArrayBuffer.Builder.PutM m Unit.Unit
putSourceCodeInfo (SourceCodeInfo r) = do
  Runtime.putRepeated 1 r.location $ Runtime.putLenDel putSourceCodeInfo_Location
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseSourceCodeInfo :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m SourceCodeInfo
parseSourceCodeInfo length = Runtime.label "SourceCodeInfo / " $
  Runtime.parseMessage SourceCodeInfo defaultSourceCodeInfo parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder SourceCodeInfoR SourceCodeInfoR)
  parseField 1 Common.LenDel = Runtime.label "location / " $ do
    x <- Runtime.parseLenDel parseSourceCodeInfo_Location
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "location") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultSourceCodeInfo :: SourceCodeInfoR
defaultSourceCodeInfo =
  { location: []
  , __unknown_fields: []
  }

mkSourceCodeInfo :: forall r1 r3. Prim.Row.Union r1 SourceCodeInfoRow r3 => Prim.Row.Nub r3 SourceCodeInfoRow => Record r1 -> SourceCodeInfo
mkSourceCodeInfo r = SourceCodeInfo $ Record.merge r defaultSourceCodeInfo


type SourceCodeInfo_LocationRow =
  ( path :: Array Int
  , span :: Array Int
  , leading_comments :: Maybe.Maybe String
  , trailing_comments :: Maybe.Maybe String
  , leading_detached_comments :: Array String
  , __unknown_fields :: Array Runtime.UnknownField
  )
type SourceCodeInfo_LocationR = Record SourceCodeInfo_LocationRow
newtype SourceCodeInfo_Location = SourceCodeInfo_Location SourceCodeInfo_LocationR
derive instance genericSourceCodeInfo_Location :: Generic.Rep.Generic SourceCodeInfo_Location _
derive instance newtypeSourceCodeInfo_Location :: Newtype.Newtype SourceCodeInfo_Location _
derive instance eqSourceCodeInfo_Location :: Eq.Eq SourceCodeInfo_Location
instance showSourceCodeInfo_Location :: Show.Show SourceCodeInfo_Location where show x = Generic.Rep.Show.genericShow x

putSourceCodeInfo_Location :: forall m. Effect.MonadEffect m => SourceCodeInfo_Location -> ArrayBuffer.Builder.PutM m Unit.Unit
putSourceCodeInfo_Location (SourceCodeInfo_Location r) = do
  Runtime.putPacked 1 r.path Encode.int32'
  Runtime.putPacked 2 r.span Encode.int32'
  Runtime.putOptional 3 r.leading_comments Encode.string
  Runtime.putOptional 4 r.trailing_comments Encode.string
  Runtime.putRepeated 6 r.leading_detached_comments Encode.string
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseSourceCodeInfo_Location :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m SourceCodeInfo_Location
parseSourceCodeInfo_Location length = Runtime.label "Location / " $
  Runtime.parseMessage SourceCodeInfo_Location defaultSourceCodeInfo_Location parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder SourceCodeInfo_LocationR SourceCodeInfo_LocationR)
  parseField 1 Common.VarInt = Runtime.label "path / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Array.snoc x
  parseField 1 Common.LenDel = Runtime.label "path / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Semigroup.append x
  parseField 2 Common.VarInt = Runtime.label "span / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "span") $ Function.flip Array.snoc x
  parseField 2 Common.LenDel = Runtime.label "span / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "span") $ Function.flip Semigroup.append x
  parseField 3 Common.LenDel = Runtime.label "leading_comments / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "leading_comments") $ Function.const $ Maybe.Just x
  parseField 4 Common.LenDel = Runtime.label "trailing_comments / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "trailing_comments") $ Function.const $ Maybe.Just x
  parseField 6 Common.LenDel = Runtime.label "leading_detached_comments / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "leading_detached_comments") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultSourceCodeInfo_Location :: SourceCodeInfo_LocationR
defaultSourceCodeInfo_Location =
  { path: []
  , span: []
  , leading_comments: Maybe.Nothing
  , trailing_comments: Maybe.Nothing
  , leading_detached_comments: []
  , __unknown_fields: []
  }

mkSourceCodeInfo_Location :: forall r1 r3. Prim.Row.Union r1 SourceCodeInfo_LocationRow r3 => Prim.Row.Nub r3 SourceCodeInfo_LocationRow => Record r1 -> SourceCodeInfo_Location
mkSourceCodeInfo_Location r = SourceCodeInfo_Location $ Record.merge r defaultSourceCodeInfo_Location


type GeneratedCodeInfoRow =
  ( annotation :: Array GeneratedCodeInfo_Annotation
  , __unknown_fields :: Array Runtime.UnknownField
  )
type GeneratedCodeInfoR = Record GeneratedCodeInfoRow
newtype GeneratedCodeInfo = GeneratedCodeInfo GeneratedCodeInfoR
derive instance genericGeneratedCodeInfo :: Generic.Rep.Generic GeneratedCodeInfo _
derive instance newtypeGeneratedCodeInfo :: Newtype.Newtype GeneratedCodeInfo _
derive instance eqGeneratedCodeInfo :: Eq.Eq GeneratedCodeInfo
instance showGeneratedCodeInfo :: Show.Show GeneratedCodeInfo where show x = Generic.Rep.Show.genericShow x

putGeneratedCodeInfo :: forall m. Effect.MonadEffect m => GeneratedCodeInfo -> ArrayBuffer.Builder.PutM m Unit.Unit
putGeneratedCodeInfo (GeneratedCodeInfo r) = do
  Runtime.putRepeated 1 r.annotation $ Runtime.putLenDel putGeneratedCodeInfo_Annotation
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseGeneratedCodeInfo :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m GeneratedCodeInfo
parseGeneratedCodeInfo length = Runtime.label "GeneratedCodeInfo / " $
  Runtime.parseMessage GeneratedCodeInfo defaultGeneratedCodeInfo parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder GeneratedCodeInfoR GeneratedCodeInfoR)
  parseField 1 Common.LenDel = Runtime.label "annotation / " $ do
    x <- Runtime.parseLenDel parseGeneratedCodeInfo_Annotation
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "annotation") $ Function.flip Array.snoc x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultGeneratedCodeInfo :: GeneratedCodeInfoR
defaultGeneratedCodeInfo =
  { annotation: []
  , __unknown_fields: []
  }

mkGeneratedCodeInfo :: forall r1 r3. Prim.Row.Union r1 GeneratedCodeInfoRow r3 => Prim.Row.Nub r3 GeneratedCodeInfoRow => Record r1 -> GeneratedCodeInfo
mkGeneratedCodeInfo r = GeneratedCodeInfo $ Record.merge r defaultGeneratedCodeInfo


type GeneratedCodeInfo_AnnotationRow =
  ( path :: Array Int
  , source_file :: Maybe.Maybe String
  , begin :: Maybe.Maybe Int
  , end :: Maybe.Maybe Int
  , __unknown_fields :: Array Runtime.UnknownField
  )
type GeneratedCodeInfo_AnnotationR = Record GeneratedCodeInfo_AnnotationRow
newtype GeneratedCodeInfo_Annotation = GeneratedCodeInfo_Annotation GeneratedCodeInfo_AnnotationR
derive instance genericGeneratedCodeInfo_Annotation :: Generic.Rep.Generic GeneratedCodeInfo_Annotation _
derive instance newtypeGeneratedCodeInfo_Annotation :: Newtype.Newtype GeneratedCodeInfo_Annotation _
derive instance eqGeneratedCodeInfo_Annotation :: Eq.Eq GeneratedCodeInfo_Annotation
instance showGeneratedCodeInfo_Annotation :: Show.Show GeneratedCodeInfo_Annotation where show x = Generic.Rep.Show.genericShow x

putGeneratedCodeInfo_Annotation :: forall m. Effect.MonadEffect m => GeneratedCodeInfo_Annotation -> ArrayBuffer.Builder.PutM m Unit.Unit
putGeneratedCodeInfo_Annotation (GeneratedCodeInfo_Annotation r) = do
  Runtime.putPacked 1 r.path Encode.int32'
  Runtime.putOptional 2 r.source_file Encode.string
  Runtime.putOptional 3 r.begin Encode.int32
  Runtime.putOptional 4 r.end Encode.int32
  Traversable.traverse_ Runtime.putFieldUnknown r.__unknown_fields

parseGeneratedCodeInfo_Annotation :: forall m. Effect.MonadEffect m => Int -> Parser.ParserT ArrayBuffer.Types.DataView m GeneratedCodeInfo_Annotation
parseGeneratedCodeInfo_Annotation length = Runtime.label "Annotation / " $
  Runtime.parseMessage GeneratedCodeInfo_Annotation defaultGeneratedCodeInfo_Annotation parseField length
 where
  parseField
    :: Runtime.FieldNumberInt
    -> Common.WireType
    -> Parser.ParserT ArrayBuffer.Types.DataView m (Record.Builder.Builder GeneratedCodeInfo_AnnotationR GeneratedCodeInfo_AnnotationR)
  parseField 1 Common.VarInt = Runtime.label "path / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Array.snoc x
  parseField 1 Common.LenDel = Runtime.label "path / " $ do
    x <- Runtime.parseLenDel $ Runtime.manyLength Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "path") $ Function.flip Semigroup.append x
  parseField 2 Common.LenDel = Runtime.label "source_file / " $ do
    x <- Decode.string
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "source_file") $ Function.const $ Maybe.Just x
  parseField 3 Common.VarInt = Runtime.label "begin / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "begin") $ Function.const $ Maybe.Just x
  parseField 4 Common.VarInt = Runtime.label "end / " $ do
    x <- Decode.int32
    pure $ Record.Builder.modify (Symbol.SProxy :: Symbol.SProxy "end") $ Function.const $ Maybe.Just x
  parseField fieldNumber wireType = Runtime.parseFieldUnknown fieldNumber wireType

defaultGeneratedCodeInfo_Annotation :: GeneratedCodeInfo_AnnotationR
defaultGeneratedCodeInfo_Annotation =
  { path: []
  , source_file: Maybe.Nothing
  , begin: Maybe.Nothing
  , end: Maybe.Nothing
  , __unknown_fields: []
  }

mkGeneratedCodeInfo_Annotation :: forall r1 r3. Prim.Row.Union r1 GeneratedCodeInfo_AnnotationRow r3 => Prim.Row.Nub r3 GeneratedCodeInfo_AnnotationRow => Record r1 -> GeneratedCodeInfo_Annotation
mkGeneratedCodeInfo_Annotation r = GeneratedCodeInfo_Annotation $ Record.merge r defaultGeneratedCodeInfo_Annotation


data FieldDescriptorProto_Type
  = FieldDescriptorProto_Type_TYPE_DOUBLE
  | FieldDescriptorProto_Type_TYPE_FLOAT
  | FieldDescriptorProto_Type_TYPE_INT64
  | FieldDescriptorProto_Type_TYPE_UINT64
  | FieldDescriptorProto_Type_TYPE_INT32
  | FieldDescriptorProto_Type_TYPE_FIXED64
  | FieldDescriptorProto_Type_TYPE_FIXED32
  | FieldDescriptorProto_Type_TYPE_BOOL
  | FieldDescriptorProto_Type_TYPE_STRING
  | FieldDescriptorProto_Type_TYPE_GROUP
  | FieldDescriptorProto_Type_TYPE_MESSAGE
  | FieldDescriptorProto_Type_TYPE_BYTES
  | FieldDescriptorProto_Type_TYPE_UINT32
  | FieldDescriptorProto_Type_TYPE_ENUM
  | FieldDescriptorProto_Type_TYPE_SFIXED32
  | FieldDescriptorProto_Type_TYPE_SFIXED64
  | FieldDescriptorProto_Type_TYPE_SINT32
  | FieldDescriptorProto_Type_TYPE_SINT64
derive instance genericFieldDescriptorProto_Type :: Generic.Rep.Generic FieldDescriptorProto_Type _
derive instance eqFieldDescriptorProto_Type :: Eq.Eq FieldDescriptorProto_Type
instance showFieldDescriptorProto_Type :: Show.Show FieldDescriptorProto_Type where show = Generic.Rep.Show.genericShow
instance ordFieldDescriptorProto_Type :: Ord.Ord FieldDescriptorProto_Type where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldDescriptorProto_Type :: Bounded.Bounded FieldDescriptorProto_Type
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldDescriptorProto_Type :: Enum.Enum FieldDescriptorProto_Type
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldDescriptorProto_Type :: Enum.BoundedEnum FieldDescriptorProto_Type
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 1 = Maybe.Just FieldDescriptorProto_Type_TYPE_DOUBLE
  toEnum 2 = Maybe.Just FieldDescriptorProto_Type_TYPE_FLOAT
  toEnum 3 = Maybe.Just FieldDescriptorProto_Type_TYPE_INT64
  toEnum 4 = Maybe.Just FieldDescriptorProto_Type_TYPE_UINT64
  toEnum 5 = Maybe.Just FieldDescriptorProto_Type_TYPE_INT32
  toEnum 6 = Maybe.Just FieldDescriptorProto_Type_TYPE_FIXED64
  toEnum 7 = Maybe.Just FieldDescriptorProto_Type_TYPE_FIXED32
  toEnum 8 = Maybe.Just FieldDescriptorProto_Type_TYPE_BOOL
  toEnum 9 = Maybe.Just FieldDescriptorProto_Type_TYPE_STRING
  toEnum 10 = Maybe.Just FieldDescriptorProto_Type_TYPE_GROUP
  toEnum 11 = Maybe.Just FieldDescriptorProto_Type_TYPE_MESSAGE
  toEnum 12 = Maybe.Just FieldDescriptorProto_Type_TYPE_BYTES
  toEnum 13 = Maybe.Just FieldDescriptorProto_Type_TYPE_UINT32
  toEnum 14 = Maybe.Just FieldDescriptorProto_Type_TYPE_ENUM
  toEnum 15 = Maybe.Just FieldDescriptorProto_Type_TYPE_SFIXED32
  toEnum 16 = Maybe.Just FieldDescriptorProto_Type_TYPE_SFIXED64
  toEnum 17 = Maybe.Just FieldDescriptorProto_Type_TYPE_SINT32
  toEnum 18 = Maybe.Just FieldDescriptorProto_Type_TYPE_SINT64
  toEnum _ = Maybe.Nothing
  fromEnum FieldDescriptorProto_Type_TYPE_DOUBLE = 1
  fromEnum FieldDescriptorProto_Type_TYPE_FLOAT = 2
  fromEnum FieldDescriptorProto_Type_TYPE_INT64 = 3
  fromEnum FieldDescriptorProto_Type_TYPE_UINT64 = 4
  fromEnum FieldDescriptorProto_Type_TYPE_INT32 = 5
  fromEnum FieldDescriptorProto_Type_TYPE_FIXED64 = 6
  fromEnum FieldDescriptorProto_Type_TYPE_FIXED32 = 7
  fromEnum FieldDescriptorProto_Type_TYPE_BOOL = 8
  fromEnum FieldDescriptorProto_Type_TYPE_STRING = 9
  fromEnum FieldDescriptorProto_Type_TYPE_GROUP = 10
  fromEnum FieldDescriptorProto_Type_TYPE_MESSAGE = 11
  fromEnum FieldDescriptorProto_Type_TYPE_BYTES = 12
  fromEnum FieldDescriptorProto_Type_TYPE_UINT32 = 13
  fromEnum FieldDescriptorProto_Type_TYPE_ENUM = 14
  fromEnum FieldDescriptorProto_Type_TYPE_SFIXED32 = 15
  fromEnum FieldDescriptorProto_Type_TYPE_SFIXED64 = 16
  fromEnum FieldDescriptorProto_Type_TYPE_SINT32 = 17
  fromEnum FieldDescriptorProto_Type_TYPE_SINT64 = 18

data FieldDescriptorProto_Label
  = FieldDescriptorProto_Label_LABEL_OPTIONAL
  | FieldDescriptorProto_Label_LABEL_REQUIRED
  | FieldDescriptorProto_Label_LABEL_REPEATED
derive instance genericFieldDescriptorProto_Label :: Generic.Rep.Generic FieldDescriptorProto_Label _
derive instance eqFieldDescriptorProto_Label :: Eq.Eq FieldDescriptorProto_Label
instance showFieldDescriptorProto_Label :: Show.Show FieldDescriptorProto_Label where show = Generic.Rep.Show.genericShow
instance ordFieldDescriptorProto_Label :: Ord.Ord FieldDescriptorProto_Label where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldDescriptorProto_Label :: Bounded.Bounded FieldDescriptorProto_Label
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldDescriptorProto_Label :: Enum.Enum FieldDescriptorProto_Label
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldDescriptorProto_Label :: Enum.BoundedEnum FieldDescriptorProto_Label
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 1 = Maybe.Just FieldDescriptorProto_Label_LABEL_OPTIONAL
  toEnum 2 = Maybe.Just FieldDescriptorProto_Label_LABEL_REQUIRED
  toEnum 3 = Maybe.Just FieldDescriptorProto_Label_LABEL_REPEATED
  toEnum _ = Maybe.Nothing
  fromEnum FieldDescriptorProto_Label_LABEL_OPTIONAL = 1
  fromEnum FieldDescriptorProto_Label_LABEL_REQUIRED = 2
  fromEnum FieldDescriptorProto_Label_LABEL_REPEATED = 3

data FileOptions_OptimizeMode
  = FileOptions_OptimizeMode_SPEED
  | FileOptions_OptimizeMode_CODE_SIZE
  | FileOptions_OptimizeMode_LITE_RUNTIME
derive instance genericFileOptions_OptimizeMode :: Generic.Rep.Generic FileOptions_OptimizeMode _
derive instance eqFileOptions_OptimizeMode :: Eq.Eq FileOptions_OptimizeMode
instance showFileOptions_OptimizeMode :: Show.Show FileOptions_OptimizeMode where show = Generic.Rep.Show.genericShow
instance ordFileOptions_OptimizeMode :: Ord.Ord FileOptions_OptimizeMode where compare = Generic.Rep.Ord.genericCompare
instance boundedFileOptions_OptimizeMode :: Bounded.Bounded FileOptions_OptimizeMode
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFileOptions_OptimizeMode :: Enum.Enum FileOptions_OptimizeMode
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFileOptions_OptimizeMode :: Enum.BoundedEnum FileOptions_OptimizeMode
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 1 = Maybe.Just FileOptions_OptimizeMode_SPEED
  toEnum 2 = Maybe.Just FileOptions_OptimizeMode_CODE_SIZE
  toEnum 3 = Maybe.Just FileOptions_OptimizeMode_LITE_RUNTIME
  toEnum _ = Maybe.Nothing
  fromEnum FileOptions_OptimizeMode_SPEED = 1
  fromEnum FileOptions_OptimizeMode_CODE_SIZE = 2
  fromEnum FileOptions_OptimizeMode_LITE_RUNTIME = 3

data FieldOptions_CType
  = FieldOptions_CType_STRING
  | FieldOptions_CType_CORD
  | FieldOptions_CType_STRING_PIECE
derive instance genericFieldOptions_CType :: Generic.Rep.Generic FieldOptions_CType _
derive instance eqFieldOptions_CType :: Eq.Eq FieldOptions_CType
instance showFieldOptions_CType :: Show.Show FieldOptions_CType where show = Generic.Rep.Show.genericShow
instance ordFieldOptions_CType :: Ord.Ord FieldOptions_CType where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldOptions_CType :: Bounded.Bounded FieldOptions_CType
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldOptions_CType :: Enum.Enum FieldOptions_CType
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldOptions_CType :: Enum.BoundedEnum FieldOptions_CType
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 0 = Maybe.Just FieldOptions_CType_STRING
  toEnum 1 = Maybe.Just FieldOptions_CType_CORD
  toEnum 2 = Maybe.Just FieldOptions_CType_STRING_PIECE
  toEnum _ = Maybe.Nothing
  fromEnum FieldOptions_CType_STRING = 0
  fromEnum FieldOptions_CType_CORD = 1
  fromEnum FieldOptions_CType_STRING_PIECE = 2

data FieldOptions_JSType
  = FieldOptions_JSType_JS_NORMAL
  | FieldOptions_JSType_JS_STRING
  | FieldOptions_JSType_JS_NUMBER
derive instance genericFieldOptions_JSType :: Generic.Rep.Generic FieldOptions_JSType _
derive instance eqFieldOptions_JSType :: Eq.Eq FieldOptions_JSType
instance showFieldOptions_JSType :: Show.Show FieldOptions_JSType where show = Generic.Rep.Show.genericShow
instance ordFieldOptions_JSType :: Ord.Ord FieldOptions_JSType where compare = Generic.Rep.Ord.genericCompare
instance boundedFieldOptions_JSType :: Bounded.Bounded FieldOptions_JSType
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumFieldOptions_JSType :: Enum.Enum FieldOptions_JSType
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumFieldOptions_JSType :: Enum.BoundedEnum FieldOptions_JSType
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 0 = Maybe.Just FieldOptions_JSType_JS_NORMAL
  toEnum 1 = Maybe.Just FieldOptions_JSType_JS_STRING
  toEnum 2 = Maybe.Just FieldOptions_JSType_JS_NUMBER
  toEnum _ = Maybe.Nothing
  fromEnum FieldOptions_JSType_JS_NORMAL = 0
  fromEnum FieldOptions_JSType_JS_STRING = 1
  fromEnum FieldOptions_JSType_JS_NUMBER = 2

data MethodOptions_IdempotencyLevel
  = MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN
  | MethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS
  | MethodOptions_IdempotencyLevel_IDEMPOTENT
derive instance genericMethodOptions_IdempotencyLevel :: Generic.Rep.Generic MethodOptions_IdempotencyLevel _
derive instance eqMethodOptions_IdempotencyLevel :: Eq.Eq MethodOptions_IdempotencyLevel
instance showMethodOptions_IdempotencyLevel :: Show.Show MethodOptions_IdempotencyLevel where show = Generic.Rep.Show.genericShow
instance ordMethodOptions_IdempotencyLevel :: Ord.Ord MethodOptions_IdempotencyLevel where compare = Generic.Rep.Ord.genericCompare
instance boundedMethodOptions_IdempotencyLevel :: Bounded.Bounded MethodOptions_IdempotencyLevel
 where
  bottom = Generic.Rep.Bounded.genericBottom
  top = Generic.Rep.Bounded.genericTop
instance enumMethodOptions_IdempotencyLevel :: Enum.Enum MethodOptions_IdempotencyLevel
 where
  succ = Generic.Rep.Enum.genericSucc
  pred = Generic.Rep.Enum.genericPred
instance boundedenumMethodOptions_IdempotencyLevel :: Enum.BoundedEnum MethodOptions_IdempotencyLevel
 where
  cardinality = Generic.Rep.Enum.genericCardinality
  toEnum 0 = Maybe.Just MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN
  toEnum 1 = Maybe.Just MethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS
  toEnum 2 = Maybe.Just MethodOptions_IdempotencyLevel_IDEMPOTENT
  toEnum _ = Maybe.Nothing
  fromEnum MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN = 0
  fromEnum MethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS = 1
  fromEnum MethodOptions_IdempotencyLevel_IDEMPOTENT = 2

